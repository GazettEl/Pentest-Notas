# 1.3.6 Funciones

Podemos pensar en una función como un script dentro de un script, lo cual es útil cuando necesitamos ejecutar el mismo código varias veces en un script. En lugar de reescribir el mismo fragmento de código una y otra vez, solo lo escribimos una vez como una función y luego llamamos a esa función según sea necesario.&#x20;

Las funciones se pueden escribir en dos formatos diferentes. El primer formato es más común a los scripts Bash:

```
function function_name {
     commandos...
}
```

El segundo formato es más familiar para los programadores de C:

```
function_name () {
     commands...
}
```

Los formatos son funcionalmente idénticos y son una cuestión de preferencia personal. Veamos un ejemplo simple:

```
❯ cat func.sh
#!/bin/bash

# function ejemplo

nueva_funcion () {
     echo "Has llamado a la funcion!"
}

nueva_funcion

❯ chmod +x func.sh

❯ ./func.sh
Has llamado a la funcion!
```

Las funciones también pueden aceptar argumentos:

```
❯ cat funcrvalue.sh
#!/bin/bash

# function ejemplo

nueva_funcion () {
     echo "Has llamado a la funcion! $1"
}

nueva_funcion $RANDOM

❯ chmod +x func-args.sh

❯ ./func-args.sh
Has llamado a la funcion!
```

En este caso, pasamos un número aleatorio, **`$RANDOM,`** en la función, que lo produce como **`$1`**, el primer argumento de las funciones. Tenga en cuenta que la definición de función **`pass_arg()`** contiene paréntesis. En otros lenguajes de programación, como C, estos contendrían los argumentos esperados, pero en Bash los paréntesis sirven solo como decoración. Nunca se utilizan. La definición de la función (la función en sí) debe aparecer en el script antes de que se llame. Lógicamente, no podemos llamar a algo que no hemos definido.

Además de pasar argumentos a las funciones Bash, por supuesto, también podemos devolver valores de las funciones Bash. Las funciones Bash en realidad no le permiten devolver un valor arbitrario en el sentido tradicional. En su lugar, una función Bash puede devolver un **`estado de salida`** (cero para el éxito, no cero para el error) o algún otro valor arbitrario al que podamos acceder más tarde desde el **`$?`** (variable global). Alternativamente, podemos establecer una variable global dentro de la función o usar la sustitución de comandos para simular un retorno tradicional.&#x20;

```
❯ cat return.sh
#!/bin/bash

return_function () {
     echo "Devolviendo un valor aleatorio!"
     return $RANDOM
}

return_function
echo "La función anterior devolvió un valor de $?"

❯ chmod +x return.sh

❯ ./return.sh
Devolviendo un valor aleatorio!
La función anterior devolvió un valor de 198

❯ ./return.sh
Devolviendo un valor aleatorio!
La función anterior devolvió un valor de 313
```

Observe que se devuelve un número aleatorio cada vez que ejecutamos el script, porque devolvimos la variable global especial $RANDOM (en $?). Si usamos la instrucción return sin el argumento $RANDOM, el estado de salida de la función (0 en este caso) se devolvería en su lugar.&#x20;

De forma predeterminada, una variable tiene un ámbito global, lo que significa que se puede acceder a ella en todo el script. Por el contrario, una variable local solo se puede ver dentro de la función, bloque de código o subshell en el que está definida. Podemos "superponer" una variable global, dándole un contexto local, precediendo la declaración con la palabra clave local, dejando intacta la variable global. La sintaxis general es:

```bash
❯ cat var-alcance.sh
#!/bin/bash

nombre1="Goku"
nombre2="Naruto"

cambio_nombres() {
     local nombre1="Edward"
     echo "Dentro de la funcion, nombre1 is $nombre1 and nombre2 is $nombre2"
     nombre2="Sasuke"
}

echo "Antes de la llamada a la funcion, nombre1 es $nombre1 y nombre2 es $nombre2"
cambio_nombres
echo "Después de la llamada a la funcion, nombre1 es $nombre1 y nombre2 es $nombre2"

❯ chmod +x var-alcance.sh

❯ ./var-alcance.sh
Dentro de la funcion, nombre1 es Goku y nombre2 es Naruto
Antes de la llamada a la funcion, nombre1 es Edward y nombre2 es Naruto
Después de la llamada a la funcion, nombre1 es John y nombre2 es Sasuke
```

Primero tenga en cuenta que declaramos dos variables globales, estableciendo **`nombre1`** en Goku y **`nombre2`** en Naruto. Luego, definimos una función y dentro de esa función, declaramos una variable local llamada **`nombre1`**, estableciendo el valor en Edward. Dado que se trataba de una variable local, la asignación global anterior no se vio afectada; **`nombre1`** seguirá estableciéndose en Goku fuera de esta función. A continuación, establecemos **`nombre2`** en Sasuke, y como no usamos la palabra clave local, estamos cambiando la variable global, y la asignación se mantiene tanto dentro como fuera de la función. Sobre la base de este ejemplo, los dos puntos siguientes resumen el alcance de la variable:

* Cambiar el valor de una variable local con el mismo nombre que una global no afectará a su valor global.&#x20;
* Cambiar el valor de una variable global dentro de una función, sin haber declarado una variable local con el mismo nombre, afectará su valor global.

{% embed url="https://ryanstutorials.net/bash-scripting-tutorial/bash-functions.php" %}
​
{% endembed %}
