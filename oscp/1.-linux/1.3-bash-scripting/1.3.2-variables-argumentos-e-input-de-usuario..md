# 1.3.2 Variables, Argumentos e input de usuario.

## Variables

Las variables se denominan lugares para almacenar datos temporalmente. Podemos establecer (o "declarar") una variable, que le asigna un valor, o leer una variable. Podemos declarar valores de variables de varias maneras. El método más fácil es establecer el valor directamente con una declaración simple name=value.**` Observe que no hay espacios antes o después del signo =`**:

```bash
❯ nombre=Super
```

Declarar una variable no tiene sentido a menos que podamos hacer referencia a ella. Para ello, precedemos a la variable con el carácter **`$`**. Cada vez que Bash encuentra esta sintaxis en un comando, reemplaza el nombre de la variable con su valor antes de la ejecución:

```bash
❯ nombre=Super
❯ apellido=Hacker
❯ echo $nombre $apellido
Super Hacker
```

Los nombres de las variables pueden ser mayúsculas, minúsculas o una mezcla de ambos. Sin embargo, Bash distingue entre mayúsculas y minúsculas, por lo que debemos ser consistentes. Además, es una buena práctica usar nombres de variables descriptivas, que hacen que nuestros scripts sean mucho más fáciles de leer y mantener. Tenga en cuenta que Bash interpreta ciertos personajes de maneras específicas.

```bash
❯ var=hola mundo
zsh: command not found: mundo
```

Para solucionar esto, podemos usar comillas simples **`'`** o comillas dobles **`"`** para encerrar nuestro texto. Sin embargo, Bash trata las comillas simples y dobles de manera diferente.&#x20;

* Comillas simples, Bash interpreta cada carácter adjunto literalmente.&#x20;
* Cuando se incluyen entre comillas dobles, todos los caracteres se ven literalmente, excepto **`$  '  \`** lo que significa que las variables se expandirán en un pase de sustitución inicial en el texto adjunto.

```bash
❯ var1='Hola'
❯ var2="New $var1"
❯ echo $var2
New Hola
```

También podemos establecer el valor de la variable en el resultado de un comando o programa. Esto se conoce como sustitución de comandos, que nos permite tomar la salida de un comando o programa (lo que normalmente se imprimiría en la pantalla) y guardarlo como el valor de una variable. Para ello, coloque el nombre de la variable entre paréntesis **`( )`**, precedido de un carácter **`$`**

Supongamos que necesitamos obtener los procesos que están corriendo para el usuario actual y almacenarlo en una variable, lo que haríamos es lo siguiente:

```bash
❯ process=$(ps -aux | grep $(whoami)
```

Expliquémoslo por partes:

1. Primero obtenemos los procesos -> **`ps -aux`**
2. Enviamos el STDOUT a grep -> **`|`**
3. Filtraremos por el resultado del comando whoami ->**` grep $(whoami)`**
   1. Ejecutara el comando que este dentro de los parentesis y guardara el resultado -> **`$(whoami)`**
4. &#x20;Para finalizar el resultado que tengamos lo guardaremos en la variable **`process`**

Sintaxis alternativa para la sustitución de comandos mediante el carácter **`` ` ``**

```bash
process=$(ps -aux | grep `whoami`)
```

## Argumentos

No todos los scripts de Bash requieren argumentos. Sin embargo, es extremadamente importante comprender cómo los interpreta Bash y cómo usarlos. Ya hemos ejecutado comandos de Linux con argumentos. Por ejemplo, cuando ejecutamos el comando ls -l /var/log, tanto -l como /var/log son argumentos del comando ls.

Los scripts Bash no son diferentes; podemos proporcionar argumentos de línea de comandos y usarlos en nuestros scripts:

```bash
❯ cat args.sh
#!/bin/bash

echo "El primer argumento $1 y el segundo argumento $2"

❯ chmod +x args.sh

❯ ./args.sh nmap masscan
El primer argumento nmap y el segundo argumento masscan

```

El método **`` ` ``** es más antiguo y normalmente no se recomienda, ya que existen diferencias en el comportamiento de los dos métodos de sustitución de comandos. También es importante tener en cuenta que la sustitución de comandos ocurre en un subshell y los cambios en las variables del subshell no alterarán las variables del proceso maestro.

Creamos un script simple, establecimos permisos de ejecución en él y luego lo ejecutamos con dos argumentos. Las variables $1 y $2 representan el primer y segundo argumento pasado al script.

### Variables especiales en Bash

| Descripción                                                 | Nombre de variable |
| ----------------------------------------------------------- | ------------------ |
| El nombre del script Bash                                   | $0                 |
| Los primeros 9 argumentos                                   | $1 - $9            |
| Número de argumentos pasados al script Bash                 | $#                 |
| Todos los argumentos pasados al script Bash                 | $@                 |
| El estado de salida del proceso ejecutado más recientemente | $?                 |
| El identificador de proceso del script actual               | \$$                |
| El nombre de usuario del usuario que ejecuta el script      | $USER              |
| The hostname of the machine                                 | $HOSTNAME          |
| A random number                                             | $RANDOM            |
| The current line number in the script                       | $LINENO            |

Algunas de estas variables especiales pueden ser muy útiles a la hora de depurar un script. Por ejemplo, podríamos obtener el estado de salida de un comando para determinar si se ejecutó correctamente o no.

{% embed url="https://ryanstutorials.net/bash-scripting-tutorial/bash-variables.php" %}

{% embed url="https://likegeeks.com/es/scripting-de-bash-parametros-y-opciones" %}

## Input de usuario

Los argumentos de la línea de comandos son una forma de entrada de usuario, pero también podemos capturar la entrada interactiva del usuario mientras se ejecuta un script con el comando **`read`**.&#x20;

Usaremos **`read`** para capturar la entrada del usuario y asignarla a una variable

```bash
❯ /bin/cat input.sh
#!/bin/bash

echo "Escribe tu direccion IP: "
read ip

echo "Tu direccion IP es: $ip"

❯ chmod +x input.sh

❯ ./input.sh
Escribe tu direccion IP: 
10.10.10.10
Tu direccion IP es: 10.10.10.10
```

Podemos alterar el comportamiento del comando **`read`**. Dos de los parámetros más utilizados:

* **`-p`**, que nos permite especificar un mensaje, y&#x20;
* **`-s`**, que hace que la entrada del usuario sea silenciosa.&#x20;

Este último es ideal para capturar credenciales de usuario:

```bash
❯ /bin/cat pass.sh
#!/bin/bash

read -p 'Username: ' user
read -ps 'Password: ' pass

echo -e "\nTu usuario es: $user y tu contrasena es: $pass"

❯ chmod +x pass.sh

❯ ./pass.sh
Username: gazette
Password: 
Tu usuario es: gazette y tu contrasena es: secret

```

{% embed url="https://ryanstutorials.net/bash-scripting-tutorial/bash-input.php" %}
