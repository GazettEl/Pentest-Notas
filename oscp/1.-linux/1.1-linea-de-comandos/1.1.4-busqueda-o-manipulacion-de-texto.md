# 1.1.4 Búsqueda o manipulación de texto

Introducción de algunos comandos para la búsqueda o manipulación de texto : grep, sed, cut y awk. El uso avanzado de algunas de estas herramientas requiere una buena comprensión de cómo funcionan las expresiones regulares (regex).&#x20;

{% hint style="info" %}
Una expresión regular es una cadena de texto especial para describir un patrón de búsqueda. Mas información en:

[https://www.adictosaltrabajo.com/2015/01/29/regexsam/](https://www.adictosaltrabajo.com/2015/01/29/regexsam/)
{% endhint %}

## grep

En pocas palabras, `grep` busca en los archivos de texto la aparición de una expresión regular dada y genera cualquier línea que contenga una coincidencia con la salida estándar, que generalmente es la pantalla del terminal. Algunos de los parámetros más utilizados,  `-r` para la búsqueda recursiva y `-i` para ignorar las distinciones de casos en patrones y datos.

A continuación un par de ejemplos desde un servidor que monte.

### Ejemplo 1

{% hint style="info" %}
netstat es una utilidad de red de línea de comandos que muestra conexiones de red para el Protocolo de control de transmisión, tablas de enrutamiento y una serie de estadísticas de interfaz de red y protocolo de red.
{% endhint %}

```
guillermo@grafana-server:~$ netstat -putan
(Not all processes could be identified, non-owned process info
 will not be shown, you would have to be root to see it all.)
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      -                   
tcp        0      0 127.0.0.53:53           0.0.0.0:*               LISTEN      -                   
tcp        0    100 192.168.100.106:22      192.168.100.23:35926    ESTABLISHED -                   
tcp6       0      0 :::22                   :::*                    LISTEN      -                   
tcp6       0      0 :::3000                 :::*                    LISTEN      -                   
udp        0      0 127.0.0.53:53           0.0.0.0:*                           -                   
udp        0      0 192.168.100.106:68      0.0.0.0:*                           -                   
udp6       0      0 fe80::20c:29ff:fe44:546 :::*                                -     
```

Si quisiéramos obtener los puertos TCP o UDP que están abiertos en nuestro sistema, podemos utilizar `netstat -putan`, ahora si quisiéramos filtrar solo los que tienen en estado LISTEN, tendríamos que hacer lo siguiente:

```
guillermo@grafana-server:~$ netstat -putan | grep "LISTEN"
(Not all processes could be identified, non-owned process info
 will not be shown, you would have to be root to see it all.)
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      -                   
tcp        0      0 127.0.0.53:53           0.0.0.0:*               LISTEN      -                   
tcp6       0      0 :::22                   :::*                    LISTEN      -                   
tcp6       0      0 :::3000                 :::*                    LISTEN      -  
```

Redirigimos la salida del comando `netstat` a `grep` para buscar solo las líneas que contengan `LISTEN`, con esto obtendremos los puertos que están en estado `LISTEN`.&#x20;

### Ejemplo 2

Supongamos que estamos en un directorio de una aplicación web y queremos buscar dentro del código la palabra "bolt", excluyendo extensiones .js, .css, .map, y .py. El resultado será el archivo seguido de la línea donde aparece seguido del contenido de esa línea (archivo:línea:contenido).

```
guillermo@grafana-server:~$ grep -rnw -I ./ -e 'bolt' --exclude='*.js' --exclude='*.css' --exclude='*.map' --exclude='*.py'
./layer.tar/app/base/static/assets/plugins/fontawesome-free/webfonts/fa-solid-900.svg:704:    <glyph glyph-name="bolt" unicode="&#xf0e7;" horiz-adv-x="320"
```

Puedes utilizar la siguiente herramienta para saber que hace cada parámetro.

{% embed url="https://explainshell.com" %}
Copia y pega lo siguiente en la pagina: grep -rnw -I ./ -r 'bolt' --exclude='\*.js'&#x20;
{% endembed %}

{% embed url="https://phoenixnap.com/kb/grep-command-linux-unix-examples" %}

## cut

El comando de **`cut`** es simple, pero a menudo es bastante útil. Se utiliza para extraer una sección de texto de una línea y enviarla a la salida estándar. Algunos de los parámetros más utilizados incluyen **`-f`** para el número de campo que estamos cortando y **`-d`** para el delimitador de campo.

{% hint style="info" %}
stty muestra o cambia las características del terminal
{% endhint %}

### Ejemplo 1

La finalidad del ejemplo es obtener el número de columnas y filas que permite nuestro sistema, esta información se puede ver en la línea 1.

```
guillermocm@grafana-server:~$ stty -a
speed 38400 baud; rows 60; columns 269; line = 0;
intr = ^C; quit = ^\; erase = ^?; kill = ^U; eof = ^D; eol = <undef>; eol2 = <undef>; swtch = <undef>; start = ^Q; stop = ^S; susp = ^Z; rprnt = ^R; werase = ^W; lnext = ^V; discard = ^O; min = 1; time = 0;
-parenb -parodd -cmspar cs8 -hupcl -cstopb cread -clocal -crtscts
-ignbrk -brkint -ignpar -parmrk -inpck -istrip -inlcr -igncr icrnl ixon -ixoff -iuclc -ixany -imaxbel iutf8
opost -olcuc -ocrnl onlcr -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0
isig icanon iexten echo echoe echok -echonl -noflsh -xcase -tostop -echoprt echoctl echoke -flusho -extproc
```

Obtenemos la primera línea.

```
guillermocm@grafana-server:~$ stty -a | head -n1
speed 38400 baud; rows 60; columns 269; line = 0;
```

Extraemos el segundo y tercer campo, teniendo como delimitador **;**

```
guillermocm@grafana-server:~$ stty -a | head -n1 | cut -d ';' -f 2-3
 rows 60; columns 269
```

{% embed url="https://www.geeksforgeeks.org/cut-command-linux-examples" %}

## sed

**`sed`** es un potente editor de flujos. También es muy complejo, por lo que solo rascaremos brevemente su superficie aquí. A un nivel muy alto, sed realiza la edición de texto en un flujo de texto, ya sea un conjunto de archivos específicos o una salida estándar. Veamos un ejemplo, siguiendo el ejemplo anterior:

### Ejemplo 1

Este ejemplo remplazará todos los `;` encontrados en el texto que toma como STDOUT y lo remplazara por saltos de línea.

```
guillermocm@grafana-server:~$ stty -a | head -n1 | cut -d ';' -f 2-3 | cut -b2- | sed 's/; /\n/'
rows 60
columns 269
```

{% embed url="https://linuxhint.com/50_sed_command_examples" %}

## awk

**`awk`** es un lenguaje de programación diseñado para el procesamiento de texto y se utiliza normalmente como una herramienta de extracción de datos e informes. También es extremadamente potente y puede ser bastante complejo, por lo que solo rascaremos la superficie aquí. Los parámetros más interesantes **`-F`**, que es el separador de campos, y el comando **`print`**, que genera el texto resultante.

### Ejercicio 1

Supongamos que queremos extraer el contenido de /etc/passwd, pero mostrarlo en otro formato (user: ### shell: \*zsh), como sabemos que el formato es el siguiente `root:x:0:0:root:/root:/usr/bin/zsh` y que está delimitado por `:` por lo tanto sabemos que tiene 7 columnas si estas están delimitadas por el carácter anteriormente dicho.&#x20;

```
$ cat /etc/passwd | awk -F ":" '{print "user:",$1,"shell:"también,$7}' | grep zsh
user: root shell: /usr/bin/zsh
user: gazette shell: /bin/zsh
```

Leemos el contenido de **`/etc/passwd`**, lo redireccionamos a **`awk`** con el parámetro **`-F`** para separar campo por el carácter que elijamos, y con `print` dentro de **`'{ }'`**` ``` poner nuestro resultado a mostrar basta con mostrar la columna $1 y $7 para obtener el resultado, también podemos agregar caracteres como **`"user:"`** o **`"shell:"`**.

{% embed url="https://linuxhint.com/20_awk_examples" %}

## regex

En el siguiente enlace podemos crear nuestras expresiones regulares o utilizar creadas por la comunidad.

{% embed url="https://regexr.com" %}
