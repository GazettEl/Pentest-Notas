# 1.1.7 Gestión de procesos

El kernel de Linux gestiona la multitarea mediante el uso de procesos. El kernel mantiene información sobre cada proceso para ayudar a mantener las cosas organizadas, y a cada proceso se le asigna un número llamado ID de proceso (PID).

El shell de Linux también introduce el concepto **`jobs`** para facilitar el flujo de trabajo del usuario durante una sesión de terminal. Como ejemplo, **`cat test.txt | wc -m`** es una canalización de dos procesos, que el shell considera un solo trabajo. El control de trabajos se refiere a la capacidad de suspender selectivamente la ejecución de trabajos y reanudar su ejecución en un momento posterior. Esto se puede lograr con la ayuda de comandos específicos

## Procesos de fondo (bg)

Los trabajos anteriores en este módulo se han ejecutado en primer plano, lo que significa que el terminal está ocupado y no se pueden ejecutar otros comandos hasta que finalice el actual.

Dado que la mayoría de nuestros ejemplos han sido cortos, esto no ha causado un problema. Sin embargo, estaremos ejecutando comandos más largos y complejos en módulos posteriores que podemos enviar a segundo plano para recuperar el control del terminal y ejecutar comandos adicionales.

La forma más rápida de poner en segundo plano un proceso es agregar un ampersand **`&`** al final del comando para enviarlo al fondo inmediatamente después de que se inicie. Probemos un breve ejemplo:

```
$ ping -c 100 localhost > result_ping &
[1] 28358

```

Enviamos 100 solicitudes de echo ICMP a la interfaz local con el comando **`ping`** y escribimos los resultados en un archivo llamado result\_ping. La ejecución se ejecuta automáticamente en segundo plano, dejando el shell libre para operaciones adicionales.

La otra opción es usando Ctrl+z después de que ya se haya iniciado. Una vez suspendido un trabajo, podemos reanudarlo en segundo plano mediante el comando **`bg`**:

```
$ ping -c 100 localhost > result_ping
^Z
[1]  + 30382 suspended  ping -c 100 localhost > result_ping

$ bg
[1]  + 30382 continued  ping -c 100 localhost > result_ping
```

El trabajo ahora se está ejecutando en segundo plano y podemos seguir usando el terminal como deseemos. Al hacer esto, tenga en cuenta que algunos procesos son sensibles al tiempo y pueden dar resultados incorrectos si se dejan suspendidos demasiado tiempo.

{% embed url="https://www.computerhope.com/unix/ubg.htm" %}

## Control jobs: jobs y fg

Para comprobar rápidamente el estado de nuestras solicitudes de echo ICMP, debemos utilizar dos comandos adicionales: **`jobs`** y **`fg`**.

```
$ ping -c 400 localhost > result_ping_localhost
^Z
[1]  + 30601 suspended  ping -c 400 localhost > result_ping_localhost

$ ping -c 400 192.168.100.1 > result_ping_gateway
^Z
[2]  + 30672 suspended  ping -c 400 192.168.100.1 > result_ping_gateway

$ jobs
[1]  - suspended  ping -c 400 localhost > result_ping_localhost
[2]  + suspended  ping -c 400 192.168.100.1 > result_ping_gateway

$ fg %1
[1]  - 30601 continued  ping -c 400 localhost > result_ping_localhost
^C

$ jobs
[2]  + suspended  ping -c 400 192.168.100.1 > result_ping_gateway

$ fg
[2]  - 30672 continued  ping -c 400 192.168.100.1 > result_ping_gateway
^C
```

En primer lugar,  ^C representa la combinación de pulsaciones de teclas **`Ctrl+c`**. Podemos utilizar este atajo para terminar un proceso de larga duración y recuperar el control del terminal.

En segundo lugar, el uso de **`%1` ** en el comando **`fg %1`** es nuevo. Hay varias formas de referirse a un trabajo en el shell. El carácter **%** seguido de un **`JobID`** representa una especificación de trabajo. El JobID puede ser un número de ID de proceso (PID) o puede utilizar una de las siguientes combinaciones de símbolos:

* %Número: Se refiere a un número de trabajo como **`%1`** o ~~**%2**~~&#x20;
* %String : Hace referencia al principio del nombre del comando suspendido, como **`%ping`**&#x20;
* %+ O **`%%`** : Se refiere al trabajo actual&#x20;
* **`%-`** : Se refiere al trabajo anterior

{% embed url="https://linuxhandbook.com/jobs-command" %}

## Control de procesos: ps y kill

Uno de los comandos más útiles para monitorear procesos en su mayoría en cualquier sistema operativo similar a Unix es **`ps`** (abreviatura de process status). A diferencia del comando **`jobs`**, **`ps`** enumera los procesos en todo el sistema, no solo para la sesión de terminal actual. Esta utilidad se considera un estándar en sistemas operativos tipo Unix y su nombre es tan reconocido que incluso en Windows PowerShell, **`ps`** es un alias de comando predefinido para el cmdlet **`Get-Process`**, que esencialmente sirve para el mismo propósito.

Como pentester, una de las primeras cosas que debe verificar después de obtener acceso remoto a un sistema es comprender qué software se está ejecutando actualmente en la máquina comprometida. Esto podría ayudarnos a elevar nuestros privilegios o recopilar información adicional para adquirir más acceso a la red.

Como ejemplo:

```
$ ps -ef
UID          PID    PPID  C STIME TTY          TIME CMD
root           1       0  0 15:20 ?        00:00:01 /sbin/init splash
root           2       0  0 15:20 ?        00:00:00 [kthreadd]
root           3       2  0 15:20 ?        00:00:00 [rcu_gp]
root           4       2  0 15:20 ?        00:00:00 [rcu_par_gp]
root           8       2  0 15:20 ?        00:00:00 [mm_percpu_wq]
root          10       2  0 15:20 ?        00:00:00 [rcu_tasks_kthre]
root          11       2  0 15:20 ?        00:00:00 [rcu_tasks_rude_]
root          12       2  0 15:20 ?        00:00:00 [rcu_tasks_trace]
root          13       2  0 15:20 ?        00:00:03 [ksoftirqd/0]
root          14       2  0 15:20 ?        00:00:08 [rcu_preempt]
root          15       2  0 15:20 ?        00:00:00 [rcub/0]
root          16       2  0 15:20 ?        00:00:00 [rcuc/0]
...
```

Las opciones **`-ef`** que usamos anteriormente representan:&#x20;

* e: seleccionar todos los procesos
* f: mostrar listado de formato completo (UID, PID, PPID, etc.)

Encontrar una aplicación en concreto en ese listado no es fácil, pero como conocemos el nombre de la aplicación que estamos buscando, podemos reemplazar el interruptor **`-e`** con **`-C`** (seleccionar por nombre de comando) de la siguiente manera:

```
$ ps -fC geany
UID          PID    PPID  C STIME TTY          TIME CMD
gazette    32898       1  8 21:39 ?        00:00:00 geany
```

Digamos que ahora queremos detener el proceso de geany sin interactuar con la GUI. El comando **`kill`** puede ayudarnos aquí, ya que su propósito es enviar una señal específica a un proceso. Para usar **`kill`**, necesitamos el **`PID`** del proceso al que queremos enviar la señal.&#x20;

```
$ kill 32898

$ ps aux | grep geany
gazette    33132  0.0  0.0   6496  2312 pts/0    S+   21:42   0:00 grep geany
```



{% embed url="https://www.geeksforgeeks.org/ps-command-in-linux-with-examples" %}

{% embed url="https://phoenixnap.com/kb/how-to-kill-a-process-in-linux#ftoc-heading-8" %}
