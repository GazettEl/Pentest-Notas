---
description: https://portswigger.net/web-security/file-path-traversal
---

# Directory traversal

En esta sección, explicaremos qué es directory traversal, describiremos cómo llevar a cabo ataques transversales de ruta y eludir obstáculos comunes, y explicaremos cómo prevenir las vulnerabilidades de directory traversal.

![](<../../.gitbook/assets/image (59).png>)

## What is directory traversal?

Directory transversal (también conocido como file path traversal) es una vulnerabilidad de seguridad web que permite a un atacante leer archivos arbitrarios en el servidor que ejecuta una aplicación. Esto puede incluir código y datos de la aplicación, credenciales para sistemas back-end y archivos confidenciales del sistema operativo. En algunos casos, un atacante podría escribir en archivos arbitrarios en el servidor, lo que les permitiría modificar los datos o el comportamiento de la aplicación y, en última instancia, tomar el control total del servidor.

## Reading arbitrary files via directory traversal

Considere una aplicación de compras que muestre imágenes de artículos a la venta. Las imágenes se cargan a través de algún HTML como el siguiente:

`<img src="/loadImage?filename=218.png">`

La dirección URL loadImage toma un parámetro de nombre de archivo y devuelve el contenido del archivo especificado. Los propios archivos de imagen se almacenan en el disco en la ubicación /var/www/images/. Para devolver una imagen, la aplicación anexa el nombre de archivo solicitado a este directorio base y utiliza una API del sistema de archivos para leer el contenido del archivo. En el caso anterior, la aplicación lee desde la siguiente ruta de archivo:

`/var/www/images/218.png`

La aplicación no implementa defensas contra los ataques directory transversal, por lo que un atacante puede solicitar la siguiente dirección URL para recuperar un archivo arbitrario del sistema de archivos del servidor:

`https://insecure-website.com/loadImage?filename=../../../etc/passwd`

Esto hace que la aplicación lea desde la siguiente ruta de archivo:

`/var/www/images/../../../etc/passwd`

En Windows, ambos casos funcionan `../` y `..\` son secuencias transversales de directorio válidas, y un ataque equivalente para recuperar un archivo estándar del sistema operativo sería`https://insecure-website.com/loadImage?filename=..\..\..\windows\win.ini`[``\
``](https://insecure-website.com/loadImage?filename=..\\..\\..\windows\win.ini)

### Lab: File path traversal, simple case

Seleccionamos cualquier item.

![](<../../.gitbook/assets/image (68).png>)

En proxy, estaremos atentos a las peticiones.

![](<../../.gitbook/assets/image (34).png>)

Vemos que intenta cargar una imagen y avanzamos a la siguiente petición.

![](<../../.gitbook/assets/image (101).png>)

Mandamos al Repeater la petición y la modificamos de la siguiente manera.

![Request](<../../.gitbook/assets/image (7).png>)

Lanzamos la petición.

![Response](<../../.gitbook/assets/image (31).png>)

Código vulnerable.

![](<../../.gitbook/assets/image (87).png>)

## Common obstacles to exploiting file path traversal vulnerabilities

Muchas aplicaciones que colocan la entrada del usuario en las rutas de los archivos implementan algún tipo de defensa contra los ataques transversales de ruta, que a menudo pueden eludirse.

Si una aplicación elimina o bloquea las secuencias transversales de directorio del nombre de archivo proporcionado por el usuario, entonces podría ser posible eludir la defensa utilizando una variedad de técnicas.

### Lab: File path traversal, traversal sequences blocked with absolute path bypass

Es posible que pueda usar una ruta absoluta desde la raíz del sistema de archivos, como `filename=/etc/passwd`, para hacer referencia directamente a un archivo sin usar secuencias transversales.

Igual que el laboratorio anterior, capturamos una petición cuando seleccionamos el item, vemos que en este ejemplo la petición es bloqueada.

![](<../../.gitbook/assets/image (4).png>)

Pero si ponemos solo la ruta absoluta, ocurre lo siguiente:

![Obtenemos el contenido del archivo /etc/passwd](<../../.gitbook/assets/image (71).png>)

### Lab: File path traversal, traversal sequences stripped non-recursively

Es posible que pueda usar secuencias transversales anidadas, como `....//` o `....\/` , que volverán a secuencias transversales simples cuando se elimine la secuencia interna.

Al igual que los ejercicios pasados, basta con usar secuencias anidadas para realizar el bypass

![](<../../.gitbook/assets/image (48).png>)

### Lab: File path traversal, traversal sequences stripped with superfluous URL-decode

Es posible que pueda utilizar varias codificaciones no estándar, como .. %c0%af o .. %252f, para omitir el filtro de entrada.

{% embed url="https://gchq.github.io/CyberChef" %}

Generamos el payload, con URL encode.

![](<../../.gitbook/assets/image (32).png>)

Pero este no funciono.

![](<../../.gitbook/assets/image (105).png>)

Ahora utilizamos dobre URL encode.

![](<../../.gitbook/assets/image (114).png>)

Enviamos el payload y este fue exitoso.

![](<../../.gitbook/assets/image (64).png>)

### Lab: File path traversal, validation of start of path

Si una aplicación requiere que el nombre de archivo proporcionado por el usuario comience con la carpeta base esperada, como /var/www/images, entonces podría ser posible incluir la carpeta base requerida seguida de secuencias transversales adecuadas. Por ejemplo:

`filename=/var/www/images/.. /.. /.. /etc/passwd`

El ejercicio es simple, debemos de darle la ruta que espera, pero debemos de al final poner el archivo que queramos

![](<../../.gitbook/assets/image (26).png>)

### Lab: File path traversal, validation of file extension with null byte bypass

Si una aplicación requiere que el nombre de archivo proporcionado por el usuario termine con una extensión de archivo esperada, como .png, es posible usar un byte nulo para terminar efectivamente la ruta de acceso del archivo antes de la extensión requerida. Por ejemplo:

`filename=.. /.. /.. /etc/passwd%00.png`

![](<../../.gitbook/assets/image (97).png>)

## Cómo prevenir un ataque transversal de directorio

La forma más efectiva de evitar las vulnerabilidades de directory traversal es evitar pasar por completo la entrada proporcionada por el usuario a las API del sistema de archivos. Muchas funciones de la aplicación que hacen esto se pueden reescribir para ofrecer el mismo comportamiento de una manera más segura.

Si se considera inevitable pasar la entrada proporcionada por el usuario a las API del sistema de archivos, se deben usar dos capas de defensa juntas para prevenir ataques:

* La aplicación debe validar la entrada del usuario antes de procesarla. Idealmente, la validación debería compararse con una lista blanca de valores permitidos. Si eso no es posible para la funcionalidad requerida, la validación debe verificar que la entrada contenga solo contenido permitido, como caracteres puramente alfanuméricos. 
* Después de validar la entrada proporcionada, la aplicación debe anexar la entrada al directorio base y utilizar una API del sistema de archivos de plataforma para canonicalizar la ruta. Debe verificar que la ruta canonicalizada comience con el directorio base esperado.

A continuación se muestra un ejemplo de código Java simple para validar la ruta canónica de un archivo basado en la entrada del usuario:

```java
File file = new File(BASE_DIRECTORY, userInput);
if (file.getCanonicalPath().startsWith(BASE_DIRECTORY)) {
    // process file
}
```

## Resumen

`filename=../../..//etc/passwd`

`filename=/etc/passwd`

`filename=....//....//....//etc/passwd`

`filename=%252E%252E%252F%252E%252E%252F%252E%252E%252F%252E%252E%252Fetc%252Fpasswd`

`filename=/var/www/images/.. /.. /.. /etc/passwd`

`filename=.. /.. /.. /etc/passwd%00.png`

## Enlace de referencia

{% embed url="https://owasp.org/www-community/Double_Encoding" %}



{% embed url="https://security.stackexchange.com/questions/11868/difference-between-directory-traversal-and-file-inclusion" %}



{% embed url="https://www.netspi.com/blog/technical/web-application-penetration-testing/directory-traversal-file-inclusion-proc-file-system/" %}



{% embed url="https://www.rcesecurity.com/2017/08/from-lfi-to-rce-via-php-sessions/" %}

