---
description: https://portswigger.net/web-security/logic-flaws
---

# Business logic

En esta sección, introduciremos el concepto de vulnerabilidades de lógica de negocio y explicaremos cómo pueden surgir debido a suposiciones erróneas sobre el comportamiento del usuario. Discutiremos el impacto potencial de las fallas lógicas y le enseñaremos cómo pueden ser explotadas.&#x20;

![](<../.gitbook/assets/image (118).png>)

## ¿Qué son las vulnerabilidades de la lógica de negocio?

Las vulnerabilidades de la lógica de negocio **son fallos en el diseño y la implementación de una aplicación que permiten a un atacante provocar un comportamiento no deseado**. Esto permite potencialmente a los atacantes manipular la funcionalidad legítima para lograr un objetivo malicioso. Estos defectos son generalmente el resultado de no anticipar los estados inusuales de la aplicación que pueden ocurrir y, en consecuencia, no manejarlos de forma segura.

Los fallos lógicos (Logic flaws) suelen ser invisibles para las personas que no los buscan explícitamente, ya que normalmente no quedan expuestos por el uso normal de la aplicación. Sin embargo, un atacante puede ser capaz de explotar las peculiaridades de comportamiento al interactuar con la aplicación de maneras que los desarrolladores nunca pretendieron.

Uno de los principales propósitos de la lógica de negocio es hacer cumplir las reglas y restricciones que se definieron al diseñar la aplicación o la funcionalidad. En términos generales, las reglas de negocio dictan cómo debe reaccionar la aplicación cuando se produce un determinado escenario. Esto incluye evitar que los usuarios hagan cosas que tengan un impacto negativo en el negocio o que simplemente no tengan sentido.

Los fallos en la lógica pueden permitir a los atacantes eludir estas reglas. Por ejemplo, podrían completar una transacción sin pasar por el flujo de trabajo de compra previsto. En otros casos, la validación de los datos suministrados por el usuario, que no funciona o no existe, puede permitir a los usuarios realizar cambios arbitrarios en los valores críticos de la transacción o enviar datos sin sentido. Al pasar valores inesperados a la lógica del lado del servidor, un atacante puede inducir a la aplicación a hacer algo que no se supone que deba hacer.

Las vulnerabilidades basadas en la lógica pueden ser extremadamente diversas y a menudo son únicas para la aplicación y su funcionalidad específica. Identificarlas suele requerir un cierto conocimiento humano, como la comprensión del dominio empresarial o los objetivos que podría tener un atacante en un contexto determinado. Esto hace que sean difíciles de detectar mediante escáneres de vulnerabilidad automatizados. Como resultado, los fallos lógicos son un gran objetivo para los cazadores de bugs y alguien que prueba de manera manual.

## ¿Cómo surgen las vulnerabilidades de la lógica de negocio?&#x20;

Las vulnerabilidades de la lógica de negocio s**uelen surgir porque los equipos de diseño y desarrollo hacen suposiciones erróneas sobre cómo los usuarios interactuarán con la aplicación**. Estas suposiciones erróneas pueden llevar a una validación inadecuada de la entrada del usuario. Por ejemplo, si los desarrolladores asumen que los usuarios pasarán datos exclusivamente a través de un navegador web, la aplicación puede depender completamente de controles débiles del lado del cliente para validar la entrada. Estos controles son fácilmente evitados por un atacante que utilice un proxy de intercepción.

En última instancia, esto significa que cuando un atacante se desvía del comportamiento esperado del usuario, la aplicación no toma las medidas apropiadas para evitarlo y, posteriormente, no maneja la situación de forma segura.

Los fallos lógicos son especialmente comunes en sistemas demasiado complicados que incluso el propio equipo de desarrollo no comprende del todo. Para evitar los fallos lógicos, los desarrolladores deben comprender la aplicación en su conjunto. Esto incluye ser consciente de cómo las diferentes funciones pueden combinarse de forma inesperada. Los desarrolladores que trabajan en grandes bases de código pueden no tener un conocimiento profundo de cómo funcionan todas las áreas de la aplicación. Alguien que trabaje en un componente podría hacer suposiciones erróneas sobre el funcionamiento de otro componente y, como resultado, introducir inadvertidamente graves fallos lógicos. Si los desarrolladores no documentan explícitamente las suposiciones que se hacen, es fácil que este tipo de vulnerabilidades se cuelen en una aplicación.

## ¿Cuál es el impacto de las vulnerabilidades de la lógica de negocio?&#x20;

El impacto de las vulnerabilidades de la lógica de negocio puede, a veces, ser bastante trivial. Es una categoría amplia y el impacto es muy variable. Sin embargo, **cualquier comportamiento no intencionado puede potencialmente conducir a ataques de alta gravedad si un atacante es capaz de manipular la aplicación de la manera correcta**. Por esta razón, lo ideal es arreglar la lógica extravagante, incluso si no puedes averiguar cómo explotarla tú mismo. Siempre existe el riesgo de que alguien pueda hacerlo.

Fundamentalmente, **el impacto de cualquier fallo lógico depende de la funcionalidad con la que esté relacionado. Si el fallo está en el mecanismo de autenticación, por ejemplo, podría tener un grave impacto en su seguridad general**. Los atacantes podrían explotar esto para escalar privilegios, o para saltarse la autenticación por completo, obteniendo acceso a datos y funcionalidades sensibles. Esto también expone una mayor superficie de ataque para otros exploits.

Una lógica defectuosa en las transacciones financieras puede, obviamente, conducir a pérdidas masivas para el negocio a través de fondos robados, fraude, etc.

También hay que tener en cuenta que, aunque los fallos lógicos no permitan a un atacante beneficiarse directamente, sí podrían permitir a un malintencionado dañar la empresa de alguna manera.

## ¿Cuáles son algunos ejemplos de vulnerabilidades de la lógica de negocio?&#x20;

La mejor manera de entender las vulnerabilidades de la lógica de negocio es observar casos del mundo real y aprender de los errores cometidos.

## Ejemplos de vulnerabilidades de la lógica empresarial

Las vulnerabilidades de la lógica empresarial son relativamente específicas del contexto en el que se producen. Sin embargo, aunque las instancias individuales de fallas lógicas difieren enormemente, pueden compartir muchos temas comunes. En particular, se pueden agrupar de forma imprecisa basándose en los errores iniciales que introdujeron la vulnerabilidad en primer lugar.

En esta sección, veremos ejemplos de algunos errores típicos que cometen los equipos de diseño y desarrollo y mostraremos cómo pueden conducir directamente a los fallos de lógica de negocio. Ya sea que estés desarrollando tus propias aplicaciones, o auditando las existentes, puedes tomar las lecciones aprendidas de estos ejemplos y aplicar el mismo pensamiento crítico a otras aplicaciones que encuentres.

Los ejemplos de fallos lógicos incluyen:

* Excesiva confianza en los controles del lado del cliente&#x20;
* No manejar las entradas no convencionales&#x20;
* Hacer suposiciones erróneas sobre el comportamiento del usuario&#x20;
* Defectos específicos del dominio&#x20;
* Proporcionar Oracle de cifrado

## Excesiva confianza en los controles del lado del cliente

Una suposición fundamentalmente errónea es que los usuarios únicamente interactuarán con la aplicación a través de la interfaz web proporcionada. Esto es especialmente peligroso porque conduce a la suposición de que la validación del lado del cliente evitará que los usuarios suministren datos maliciosos. Sin embargo, un atacante puede simplemente utilizar herramientas como Burp Proxy para manipular los datos después de que hayan sido enviados por el navegador, pero antes de que pasen a la lógica del lado del servidor. Esto hace que los controles del lado del cliente sean inútiles.

Aceptar los datos al pie de la letra, sin realizar las comprobaciones de integridad adecuadas y la validación del lado del servidor, puede permitir a un atacante hacer todo tipo de daños con un esfuerzo relativamente mínimo. Exactamente lo que son capaces de lograr depende de la funcionalidad y lo que está haciendo con los datos controlables. En el contexto adecuado, este tipo de fallo puede tener consecuencias devastadoras tanto para la funcionalidad relacionada con el negocio como para la seguridad del propio sitio web.

### Lab: Excessive trust in client-side controls

Tenemos las siguientes credenciales: `wiener:peter`

Iniciamos sesión y el objetivo será comprar, la chaqueta de cuero con valor de $1377.

![](<../.gitbook/assets/imagen (89).png>)

Para ello primero agregamos al carrito de compras la chaqueta y analizamos la petición. Observamos que cuando agregamos un producto al carrito, se tramitaba una petición POST hacia **`/cart`**, con algunos datos entre ellos la cantidad y el precio, aquí es cuando podemos intentar algo.

![](<../.gitbook/assets/imagen (25).png>)

Antes de probar cambiar los datos que se tramitan en la petición, podemos simplemente ver como es la respuesta.&#x20;

![](<../.gitbook/assets/imagen (49).png>)

La petición fue recibida con éxito, podemos probar modificar el dato `price.`Cambiar la cantidad del precio para saber si la petición se tramita correctamente. Antes de realizar esta petición, eliminamos el producto que se había agregado, como prueba.

![](<../.gitbook/assets/imagen (31).png>)

Enviamos la petición y vemos que la respuesta es exitosa.

![](<../.gitbook/assets/imagen (21).png>)

Si todo salió bien, deberíamos de tener el precio de $0.01 para la chaqueta de cuero.

![](<../.gitbook/assets/imagen (24).png>)

Solo tendíamos que comprar el producto.

![](<../.gitbook/assets/imagen (51).png>)

### Lab: 2FA broken logic

[\
](https://twitter.com/share?url=https%3a%2f%2fportswigger.net%2fweb-security%2fauthentication%2fmulti-factor%2flab-2fa-broken-logic\&text=Lab%3a+2FA+broken+logic+%7c+Web+Security+Academy%0A)Este ejercicio puede visualizarse en esta sección.

{% content-ref url="authentication-vulnerabilities/vulnerabilities-in-multi-factor-authentication.md" %}
[vulnerabilities-in-multi-factor-authentication.md](authentication-vulnerabilities/vulnerabilities-in-multi-factor-authentication.md)
{% endcontent-ref %}

## No manejar las entradas no convencionales

Uno de los objetivos de la lógica de la aplicación es restringir la entrada del usuario a valores que se adhieran a las reglas del negocio. Por ejemplo, la aplicación puede estar diseñada para aceptar valores arbitrarios de un determinado tipo de datos, pero la lógica determina si este valor es aceptable o no desde la perspectiva del negocio. Muchas aplicaciones incorporan límites numéricos en su lógica. Esto puede incluir límites diseñados para gestionar el inventario, aplicar restricciones presupuestarias, activar fases de la cadena de suministro, etc.

Tomemos el sencillo ejemplo de una tienda online. Al pedir productos, los usuarios suelen especificar la cantidad que quieren pedir. Aunque, en teoría, cualquier número entero es una entrada válida, la lógica empresarial puede impedir que los usuarios pidan más unidades de las que tienen en stock, por ejemplo.

Para implementar reglas como ésta, los desarrolladores necesitan anticipar todos los escenarios posibles e incorporar formas de manejarlos en la lógica de la aplicación. En otras palabras, tienen que indicar a la aplicación si debe permitir una entrada determinada y cómo debe reaccionar en función de diversas condiciones. Si no hay una lógica explícita para manejar un caso determinado, esto puede conducir a un comportamiento inesperado y potencialmente explotable.

Por ejemplo, un tipo de dato numérico puede aceptar valores negativos. Dependiendo de la funcionalidad relacionada, puede no tener sentido que la lógica de negocio lo permita. Sin embargo, si la aplicación no realiza una validación adecuada del lado del servidor y rechaza esta entrada, un atacante puede ser capaz de pasar un valor negativo e inducir un comportamiento no deseado.

Considere una transferencia de fondos entre dos cuentas bancarias. Esta funcionalidad casi seguro que comprobará si el remitente tiene fondos suficientes antes de completar la transferencia:

```
$transferAmount = $_POST['amount'];
$currentBalance = $user->getBalance();

if ($transferAmount <= $currentBalance) {
    // Complete the transfer
} else {
    // Block the transfer: insufficient funds
}
```

Pero si la lógica no impide suficientemente que los usuarios proporcionen un valor negativo en el parámetro de la cantidad, esto podría ser aprovechado por un atacante tanto para eludir la comprobación del saldo como para transferir fondos en la dirección "equivocada". Si el atacante enviara -1000 dólares a la cuenta de la víctima, podría recibir 1000 dólares de la víctima. La lógica siempre evaluaría que -1000 es menos que el saldo actual y aprobaría la transferencia.

Simples fallos lógicos como éste pueden ser devastadores si se producen en la funcionalidad adecuada. También son fáciles de pasar por alto tanto durante el desarrollo como durante las pruebas, especialmente teniendo en cuenta que estas entradas pueden estar bloqueadas por controles del lado del cliente en la interfaz web.

Al auditar una aplicación, debe utilizar herramientas como Burp Proxy y Repeater para intentar enviar valores no convencionales. En particular, intente introducir valores en rangos que los usuarios legítimos probablemente nunca introduzcan. Esto incluye entradas numéricas excepcionalmente altas o excepcionalmente bajas y cadenas anormalmente largas para campos basados en texto. Incluso puede probar con tipos de datos inesperados. Al observar la respuesta de la aplicación, debes intentar responder a las siguientes preguntas:

* ¿Existen límites impuestos a los datos?
* ¿Qué ocurre cuando se alcanzan esos límites?
* ¿Se está realizando alguna transformación o normalización en la entrada?

Esto puede exponer una validación de entrada débil que le permita manipular la aplicación de maneras inusuales. Tenga en cuenta que si encuentra un formulario en el sitio web de destino que no maneja con seguridad la entrada no convencional, es probable que otros formularios tengan los mismos problemas.

### Lab: High-level logic vulnerabilityLab: High-level logic vulnerability

Iniciamos sesion, despues nos vamos al producto indicado que se mos pide comprar, lo agregamos al carrito pero antes de agregarlo debemos de capturar esta peticion.

![](<../.gitbook/assets/imagen (22).png>)

Si alteramos la cantidad y la cambiamos por -1 y enviamos la peticion.

![](<../.gitbook/assets/imagen (10).png>)

Con esto obtenemos un mensaje de error.

![](<../.gitbook/assets/imagen (96).png>)

Podemos ver que tenemos un saldo negativo, como podriamos hacer para que este saldo dea positivo y realizar la transaccion?, tal ves agregando mas productos, solo habra que ajustar la cantidad necesaria.

![](<../.gitbook/assets/imagen (61).png>)

Por ejemplo, en este caso, estaria cumpliendo condicion respecto al credito, ya que la cuenta tiene suficiente credito para pagar el total.

![](<../.gitbook/assets/imagen (7).png>)

Solo tendriamos que ordenar.

![](<../.gitbook/assets/imagen (100).png>)

Bueno el ejercicio salio mal, ya que se tenia que comprar la chaqueta de cuero pero lo olvide, siguiendo lo mismo que hice anteriormente podemos llegar al siguiente resultado.

![](<../.gitbook/assets/imagen (4).png>)

### Lab: Low-level logic flaw

Capturamos la petición cuando añadimos un producto al carrito, solamente observamos que se envia la cantidad de producto.

![](<../.gitbook/assets/imagen (59).png>)

En el carrito solo se agregaria un producto.

![](<../.gitbook/assets/imagen (81).png>)

Probamos a agregar una cantidad mayor directamente en la peticion. Por ejemplo, agregar 100.

![](<../.gitbook/assets/imagen (101).png>)

Pero no fue posible ya que sobrepasa la cantidad, intentaremos con un numero menor, el 99, vemos que es valido.

![](<../.gitbook/assets/imagen (64).png>)

Con python podemos crear un pequeno script para agregar productos y ver como se comporta la aplicacion. El siguiente script agrega una cantidiad 99\*100000 pero podemos pausarlo en cualquier momento por lo que debemos de estar monitoreando la pagina para saber que es lo que sucede.

```
import requests

for i in range(0,100000):
    burp0_url = "https://ac951f221f5d4fcbc0503f1900fc00e7.web-security-academy.net:443/cart"
    burp0_cookies = {"session": "PpoOq0XsMSn5zuJdYxR19FiuvbLLfeR1"}
    burp0_headers = {"Cache-Control": "max-age=0", "Sec-Ch-Ua": "\"Chromium\";v=\"95\", \";Not A Brand\";v=\"99\"", "Sec-Ch-Ua-Mobile": "?0", "Sec-Ch-Ua-Platform": "\"Linux\"", "Upgrade-Insecure-Requests": "1", "Origin": "https://ac951f221f5d4fcbc0503f1900fc00e7.web-security-academy.net", "Content-Type": "application/x-www-form-urlencoded", "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.54 Safari/537.36", "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9", "Sec-Fetch-Site": "same-origin", "Sec-Fetch-Mode": "navigate", "Sec-Fetch-User": "?1", "Sec-Fetch-Dest": "document", "Referer": "https://ac951f221f5d4fcbc0503f1900fc00e7.web-security-academy.net/product?productId=1", "Accept-Encoding": "gzip, deflate", "Accept-Language": "en-US,en;q=0.9", "Connection": "close"}
    burp0_data = {"productId": "1", "redir": "PRODUCT", "quantity": "99"}
    requests.post(burp0_url, headers=burp0_headers, cookies=burp0_cookies, data=burp0_data)
```

Agregamos la cantidad de 28709, en este caso lo pause porque el precio habia pasado a ser negativo.

![](<../.gitbook/assets/imagen (1).png>)

Para contrarrestar el precio negativo agregue el producto con ID 2 hasta ver si este numero pasaba a ser positivo.

```
Simport requests

for i in range(0,100000):    
    burp0_url = "https://ac951f221f5d4fcbc0503f1900fc00e7.web-security-academy.net:443/cart"
    burp0_cookies = {"session": "PpoOq0XsMSn5zuJdYxR19FiuvbLLfeR1"}
    burp0_headers = {"Cache-Control": "max-age=0", "Sec-Ch-Ua": "\"Chromium\";v=\"95\", \";Not A Brand\";v=\"99\"", "Sec-Ch-Ua-Mobile": "?0", "Sec-Ch-Ua-Platform": "\"Linux\"", "Upgrade-Insecure-Requests": "1", "Origin": "https://ac951f221f5d4fcbc0503f1900fc00e7.web-security-academy.net", "Content-Type": "application/x-www-form-urlencoded", "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.54 Safari/537.36", "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9", "Sec-Fetch-Site": "same-origin", "Sec-Fetch-Mode": "navigate", "Sec-Fetch-User": "?1", "Sec-Fetch-Dest": "document", "Referer": "https://ac951f221f5d4fcbc0503f1900fc00e7.web-security-academy.net/product?productId=2", "Accept-Encoding": "gzip, deflate", "Accept-Language": "en-US,en;q=0.9", "Connection": "close"}
    burp0_data = {"productId": "2", "redir": "PRODUCT", "quantity": "99"}
    requests.post(burp0_url, headers=burp0_headers, cookies=burp0_cookies, data=burp0_data)
```

El numero negativo se ira acercando a cero con cada peticion que hagamos.

![](<../.gitbook/assets/imagen (91).png>)

Detendremos el script hasta que se acerque a cero y despues lo manipularemos desde la web hasta alcanzar el rango de precio que podamos pagar.

![](<../.gitbook/assets/imagen (9).png>)

Basta con hacer el pedido.

![](<../.gitbook/assets/imagen (12).png>)

### Lab: Inconsistent handling of exceptional input

Vamos a explotar un fallo lógico en su proceso de registro de cuentas para obtener acceso a la funcionalidad administrativa. Para resolver el laboratorio, accede al panel de administración y eliminar a Carlos.

No contamos con un usuario para iniciar sesion y solo podriamos registrarnos, por lo que podemos descrubir contenido con alguna herramienta que realice fuzzing para saber si hay algo mas.

```
gobuster dir -u https://acef1f1b1e4cf028c04b19170023003c.web-security-academy.net/ -w ~/Pentesting/wordlist/SecLists/Discovery/Web-Content/directory-list-2.3-medium.txt -t 50 -k -q
/login                (Status: 200) [Size: 3193]
/register             (Status: 200) [Size: 3382]
/product              (Status: 400) [Size: 30]  
/admin                (Status: 401) [Size: 2633]
/Login                (Status: 200) [Size: 3193]
/logout               (Status: 302) [Size: 0] [--> /]
/Product              (Status: 400) [Size: 30]       
/filter               (Status: 200) [Size: 10745]    
/Register             (Status: 200) [Size: 3382]     
/Logout               (Status: 302) [Size: 0] [--> /]
/Filter               (Status: 200) [Size: 10745]    
/my-account           (Status: 302) [Size: 0] [--> /login]
```

Podemos ver que existe contenido en /register y no somos redireccionados a alguna parte por lo tanto podemos visitarlo.

![](<../.gitbook/assets/imagen (33).png>)

Mientras tanto en /admin podemos ver que solo es accesible para los usuarios DontWannaCry.

![](<../.gitbook/assets/imagen (48).png>)

Nos registraremos como un usuario normal.

![](<../.gitbook/assets/imagen (77).png>)

Y observamos que podemos hacer, vemos que podemos ver el correo electronico con el que nos hemos registrado.

![](<../.gitbook/assets/imagen (26).png>)

Al registrarnos con un correo con una cadena de caracreres demasiada larga, la cadena esta limitada&#x20;

![](<../.gitbook/assets/imagen (87).png>)

Podemos ver que solo se nos mostraran 255 caracteres.

![](<../.gitbook/assets/imagen (29).png>)

Podemos generar un correo exactamente con la cantidad de caracteres el cual usaremos para registrarnos.

![](<../.gitbook/assets/imagen (11).png>)

Si nos registramos con el correo:

bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb@dontwannacry.com&#x20;

No podremos obtener el link de verificacion para poder acceder, por lo tanto debemos de comprobar si al añadir el correo que se nos proporciona es valido, de la siguiente manera:

bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb@dontwannacry.com.exploit-acc11f521e0df0b1c0ad19ca01ae00e4.web-security-academy.net

Si nos registramos con este correo podemos verificar la cuenta e iniciar sesion.

![](<../.gitbook/assets/imagen (53).png>)

Al iniciar sesion podemos ver que se nos habilita el panel de administrador.

![](<../.gitbook/assets/imagen (41).png>)

Podemos borrar el usuario admin, en este caso carlos.

![](<../.gitbook/assets/imagen (82).png>)

## Hacer suposiciones erróneas sobre el comportamiento de los usuarios

Una de las causas más comunes de las vulnerabilidades lógicas es hacer suposiciones erróneas sobre el comportamiento del usuario. Esto puede conducir a una amplia gama de problemas en los que los desarrolladores no han considerado escenarios potencialmente peligrosos que violan estas suposiciones. En esta sección, proporcionaremos algunos ejemplos de precaución de suposiciones comunes que deben ser evitadas y demostraremos cómo pueden llevar a peligrosas fallas lógicas.

#### Los usuarios de confianza no siempre seguirán siendo de confianza

Las aplicaciones pueden parecer seguras porque implementan medidas aparentemente robustas para hacer cumplir las reglas de negocio. Lamentablemente, algunas aplicaciones cometen el error de asumir que, habiendo pasado estos estrictos controles inicialmente, el usuario y sus datos pueden ser de confianza indefinidamente.

Si las reglas de negocio y las medidas de seguridad no se aplican de forma coherente en toda la aplicación, esto puede conducir a lagunas potencialmente peligrosas que pueden ser explotadas por un atacante.

### Lab: Inconsistent security controls

Nos registramos.

![](<../.gitbook/assets/imagen (17).png>)

Una vez registrados solo podemos actualizar el correo.

![](<../.gitbook/assets/imagen (56).png>)

Realizamos fuzzing.

```
gobuster dir -u https://ac541f2b1ec8656ec0257f9c00e400a3.web-security-academy.net/ -w ~/Pentesting/wordlist/SecLists/Discovery/Web-Content/directory-list-2.3-medium.txt -t 50 -k -q
/register             (Status: 200) [Size: 3346]
/login                (Status: 200) [Size: 3157]
/product              (Status: 400) [Size: 30]  
/admin                (Status: 401) [Size: 2597]
/Login                (Status: 200) [Size: 3157]
/logout               (Status: 302) [Size: 0] [--> /]
/Product              (Status: 400) [Size: 30]       
/filter               (Status: 200) [Size: 10698]    
/Register             (Status: 200) [Size: 3346]     
/Logout               (Status: 302) [Size: 0] [--> /]
/Filter               (Status: 200) [Size: 10698]  
```

Nos dice que solo es accesible para los usuarios DontWannaCry.

![](<../.gitbook/assets/imagen (39).png>)

Podriamos actualizar el correo poniendo @dontwannacry.com

![](<../.gitbook/assets/imagen (54).png>)



Se nos ha actualizado y podemos ver el panel de administracion.

![](<../.gitbook/assets/imagen (50).png>)

Eliminamos el usuario que se nos pide.

![](<../.gitbook/assets/imagen (63).png>)

#### Los usuarios no siempre suministran datos obligatorios

Una idea errónea es que los usuarios siempre proporcionarán valores para los campos de entrada obligatorios. Los navegadores pueden impedir que los usuarios normales envíen un formulario sin una entrada obligatoria, pero como sabemos, los atacantes pueden manipular los parámetros en tránsito. Esto se extiende incluso a la eliminación de los parámetros por completo.

Esto es un problema particular en los casos en que se implementan múltiples funciones dentro del mismo script del lado del servidor. En este caso, la presencia o ausencia de un parámetro concreto puede determinar qué código se ejecuta. Eliminar los valores de los parámetros puede permitir a un atacante acceder a rutas de código que se supone que están fuera de su alcance.

Cuando se prueban los fallos lógicos, se debe intentar eliminar cada parámetro sucesivamente y observar qué efecto tiene esto en la respuesta. Debes asegurarte de:

* Elimine sólo un parámetro a la vez para asegurarse de que se alcanzan todas las rutas de código relevantes.
* Intente eliminar tanto el nombre del parámetro como el valor. El servidor suele manejar ambos casos de forma diferente.
* Siga los procesos de varias etapas hasta su finalización. A veces, la manipulación de un parámetro en un paso tendrá un efecto en otro paso más adelante en el flujo de trabajo.

Esto se aplica tanto a los parámetros URL como a los POST, pero no olvides comprobar también las cookies. Este simple proceso puede revelar algunos comportamientos extraños de la aplicación que pueden ser explotables.

### Lab: Weak isolation on dual-use endpoint

Ingresamos con el usuario que se nos asigno, como objetivo tenemos que hacernos de la cuenta de carlos.

![](<../.gitbook/assets/imagen (16).png>)

Podemos capturar la petición cuando cambiamos la contraseña, obserbamos que los datos que se envian son el usuario, la contraseña y la nueva contraseña.

![](<../.gitbook/assets/imagen (43).png>)

La petición se realiza correctamente y se cambia la contraseña, pero, que pasaría si cambiásemos el usuario por administrador.

![](<../.gitbook/assets/imagen (62).png>)

Enviamos la petición y veamos lo que pasa, podemos ver que se cambió el usuario a administrator, pero el mansaje aparece que la contraseña es incorrecta.

![](<../.gitbook/assets/imagen (46).png>)

Probamos a eliminar current-password para saber si se omite este paso y cambiamos la contraseña.

![](<../.gitbook/assets/imagen (65).png>)

Si todo salio bien deberiamos de haber obtenido la siguiente respuesta.&#x20;

![](<../.gitbook/assets/imagen (55).png>)

Por lo que solo deberíamos salir nos dé la sesión e iniciar con administrator.

![](<../.gitbook/assets/imagen (92).png>)

Podemos tener acceso al panel de administración y eliminar a carlos.

![](<../.gitbook/assets/imagen (78).png>)

### Lab: Password reset broken logic

Podemos iniciar sesion pero no hay mucho que podamos hacer por lo que vamos a hacer uso de "Forgot password?".

![](<../.gitbook/assets/imagen (44).png>)

En la peticion podemos ver que los datos tramitados son solo el correo, pero no podemos hacer mucho.

![](<../.gitbook/assets/imagen (102).png>)

Podemos abrir el link que se nos envía pasa saber que datos se tramitan en la petición que se hace cuando cambiamos la contraseña.

![](<../.gitbook/assets/imagen (45).png>)

En tal caso, solo debemos de cambiar el usuario al que queramos acceder.&#x20;

![](<../.gitbook/assets/imagen (85).png>)

Comprobamos que ha funcionado.

![](<../.gitbook/assets/imagen (19).png>)

#### Los usuarios no siempre seguirán la secuencia prevista

Muchas transacciones se basan en flujos de trabajo predefinidos que consisten en una secuencia de pasos. La interfaz web suele guiar a los usuarios a través de este proceso, llevándolos al siguiente paso del flujo de trabajo cada vez que completan el actual. Sin embargo, los atacantes no necesariamente se adherirán a esta secuencia prevista. No tener en cuenta esta posibilidad puede conducir a peligrosos fallos que pueden ser relativamente sencillos de explotar.

Por ejemplo, muchos sitios web que implementan la autenticación de dos factores (2FA) requieren que los usuarios se registren en una página antes de introducir un código de verificación en otra página. Asumir que los usuarios siempre seguirán este proceso hasta su finalización y, como resultado, no verificar que lo hagan, puede permitir a los atacantes saltarse el paso de 2FA por completo.

### Lab: 2FA simple bypass

Este ejercicio puede visualizarse en esta sección.

{% content-ref url="authentication-vulnerabilities/vulnerabilities-in-multi-factor-authentication.md" %}
[vulnerabilities-in-multi-factor-authentication.md](authentication-vulnerabilities/vulnerabilities-in-multi-factor-authentication.md)
{% endcontent-ref %}

Hacer suposiciones sobre la secuencia de eventos puede conducir a una amplia gama de problemas incluso dentro del mismo flujo de trabajo o funcionalidad. Utilizando herramientas como Burp Proxy y Repeater, una vez que un atacante ha visto una solicitud, puede reproducirla a voluntad y utilizar la navegación forzada para realizar cualquier interacción con el servidor en el orden que desee. Esto les permite completar diferentes acciones mientras la aplicación está en un estado inesperado.

Para identificar este tipo de fallos, debes utilizar la navegación forzada para enviar solicitudes en una secuencia no deseada. Por ejemplo, puede saltarse ciertos pasos, acceder a un mismo paso más de una vez, volver a pasos anteriores, etc. Tome nota de cómo se accede a los diferentes pasos. Aunque a menudo sólo se envía una solicitud GET o POST a una URL específica, a veces se puede acceder a los pasos enviando diferentes conjuntos de parámetros a la misma URL. Al igual que con todos los fallos lógicos, intenta identificar qué suposiciones han hecho los desarrolladores y dónde se encuentra la superficie de ataque. A continuación, puedes buscar formas de violar estas suposiciones.

Tenga en cuenta que este tipo de pruebas a menudo causará excepciones porque las variables esperadas tienen valores nulos o no inicializados. Llegar a un lugar en un estado parcialmente definido o inconsistente también es probable que haga que la aplicación se queje. En este caso, asegúrese de prestar mucha atención a cualquier mensaje de error o información de depuración que encuentre. Estos pueden ser una valiosa fuente de revelación de información, que puede ayudarte a afinar tu ataque y a entender detalles clave sobre el comportamiento del back-end.

### Lab: Insufficient workflow validation

Analizaremos el proceso cuando compramos un producto, solo agregaremos el producto que queramos.

![](<../.gitbook/assets/imagen (20).png>)

Una vez que hayamos dado en ordenar, se tramitaran las siguientes peticiones.

Peticion 1.

![](<../.gitbook/assets/imagen (18).png>)

Peticion 2.

![](<../.gitbook/assets/imagen (8).png>)

El flujo para realizar un pedido podemos ver que la primera petición POST /cart/checkout podemos pensar que aquí se comprueba que hay saldo en la cuenta para adquirir un producto. Posteriormente hay una petición GET /cart/order-confirmation?order-confirmed=true, la cual confirma la orden de compra, antes de realizar algo volví a hacer lo mismo pero con un producto más caro. La segunda petición era GET /cart?err=INSUFFICIENT\_FUNDS la cual podemos deducir que se trata de algún tipo de validación para decirnos que no hay fondos.

Por lo que agregaremos el producto a comprar.

![](<../.gitbook/assets/imagen (34).png>)

La primera petición se mandará tal y como esta.

![](<../.gitbook/assets/imagen (6).png>)

En la segunda peticion cambiaremos  /cart?err=INSUFFICIENT\_FUNDS por /cart/order-confirmation?order-confirmed=true para que el pedido sea confirmado, sin necesidad de pagar algo.

![](<../.gitbook/assets/imagen (2).png>)

En la respuesta podemos observar que se a adquirido el producto.

![](<../.gitbook/assets/imagen (60).png>)

### Lab: Authentication bypass via flawed state machine

Iniciaremos sesión de manera normal, mientras capturamos las peticiones.

![](<../.gitbook/assets/imagen (86).png>)

Petición eligiendo user.

![](<../.gitbook/assets/imagen (97).png>)

Petición eligiendo content author.

![](<../.gitbook/assets/imagen (94).png>)

Observamos que lo unico que cambia el rol, al momento de nevegar por la web, no parece haber alguna direfiencia, hicimos fuzzing para descurbir mas contenido.

```
gobuster dir -u https://acf11ff31fb4d7ffc0ca1b65007e00e7.web-security-academy.net/ -w ~/Pentesting/wordlist/SecLists/Discovery/Web-Content/directory-list-2.3-medium.txt -t 50 -k -q
/login                (Status: 200) [Size: 2962]
/product              (Status: 400) [Size: 30]  
/admin                (Status: 401) [Size: 2399]
/Login                (Status: 200) [Size: 2962]
/logout               (Status: 302) [Size: 0] [--> /]
/Product              (Status: 400) [Size: 30]       
/filter               (Status: 200) [Size: 10494]    
/Logout               (Status: 302) [Size: 0] [--> /]
/Filter               (Status: 200) [Size: 10494]    
/my-account           (Status: 302) [Size: 0] [--> /login]
```

Vemos en /admins que solo se le permite entrar aqui si estamos como administrator.

![](<../.gitbook/assets/imagen (69).png>)

En la petición donde se define el rol podemos probar a introducir administrator o admin para saber si es válido.

![](<../.gitbook/assets/imagen (84).png>)

Pero al entrar a /admin, aun seguimos sin poder acceder. Intentaremos hacer Drop a la petición GET /role-selector.

![](<../.gitbook/assets/imagen (79).png>)

Ahora que no hemos definido algun rol podemos ver si carga el contenido de /admin, de esta menera nos combertiriamos en administradores.

![](<../.gitbook/assets/imagen (83).png>)

## Defectos específicos del dominio&#x20;

En muchos casos, se encontrarán fallos lógicos que son específicos del dominio del negocio o del propósito del sitio.

La funcionalidad de los descuentos de las tiendas online es una superficie de ataque clásica a la hora de buscar fallos lógicos. Esto puede ser una potencial mina de oro para un atacante, con todo tipo de fallos lógicos básicos en la forma en que se aplican los descuentos.

Por ejemplo, consideremos una tienda online que ofrece un 10% de descuento en pedidos superiores a 1000 dólares. Esto podría ser vulnerable al abuso si la lógica de negocio no comprueba si el pedido se ha modificado después de aplicar el descuento. En este caso, un atacante podría simplemente añadir artículos a su cesta hasta alcanzar el umbral de los 1000 dólares, y luego eliminar los artículos que no quiere antes de realizar el pedido. Entonces recibirían el descuento en su pedido aunque ya no satisfaga los criterios previstos.

Debe prestar especial atención a cualquier situación en la que los precios u otros valores sensibles se ajusten en función de los criterios determinados por las acciones del usuario. Intente comprender qué algoritmos utiliza la aplicación para realizar estos ajustes y en qué momento se realizan. A menudo se trata de manipular la aplicación para que se encuentre en un estado en el que los ajustes aplicados no se correspondan con los criterios originales previstos por los desarrolladores.

Para identificar estas vulnerabilidades, hay que pensar detenidamente en los objetivos que podría tener un atacante y tratar de encontrar diferentes formas de conseguirlo utilizando la funcionalidad proporcionada. Esto puede requerir un cierto nivel de conocimiento específico del dominio para entender lo que podría ser ventajoso en un contexto determinado. Para utilizar un ejemplo sencillo, es necesario entender las redes sociales para comprender las ventajas de forzar a un gran número de usuarios a seguirte.

Sin este conocimiento del ámbito, puedes descartar un comportamiento peligroso porque simplemente no eres consciente de sus posibles efectos en cadena. Del mismo modo, puede que te cueste unir los puntos y darte cuenta de cómo dos funciones pueden combinarse de forma perjudicial. Para simplificar, los ejemplos utilizados en este tema son específicos de un dominio con el que todos los usuarios estarán ya familiarizados, a saber, una tienda online. Sin embargo, tanto si te dedicas a la caza de bugs como a la realización de pentesting, o incluso si eres un simple desarrollador que trata de escribir un código más seguro, es posible que en algún momento te encuentres con aplicaciones de dominios menos familiares. En este caso, deberías leer toda la documentación posible y, cuando esté disponible, hablar con expertos en la materia del dominio para obtener su opinión. Esto puede parecer mucho trabajo, pero cuanto más oscuro sea el dominio, más probable será que otros probadores hayan pasado por alto muchos errores.

### Lab: Flawed enforcement of business rules

Agregamos el producto a comprar con todo y descuento.

![](<../.gitbook/assets/imagen (30).png>)

Se verá algo así.

![](<../.gitbook/assets/imagen (70).png>)

SI quisiéramos tener más descuento tendiéramos que agregar el mismo cupón varias veces, pero esto no es posible, ya que tiene cierta validación que no permite hacerlo. Pero una de las cosas que podemos hacer es obtener un cupón yéndonos hasta el final de la página y suscribiéndonos a los boletines informativos. Aparecerá lo siguiente.

![](<../.gitbook/assets/imagen (71).png>)

Se ha agregado correctamente.

![](<../.gitbook/assets/imagen (32).png>)

Existe un defecto que permite seguir agregando codigos de descuento, solo que el codigo no debe de ser el mismo que el anterior, de la siguiente manera podemos comprar el objeto a precio $0.

![](<../.gitbook/assets/imagen (103).png>)

Haremos el pedido y se realizara con exito.

![](<../.gitbook/assets/imagen (76).png>)

### Lab: Infinite money logic flaw



## Proporcionar Oracle de cifrado

Pueden producirse situaciones peligrosas cuando se encripta una entrada controlable por el usuario y el texto cifrado resultante se pone a su disposición de alguna manera. Este tipo de entrada se conoce a veces como "Oracle cifrado". Un atacante puede utilizar esta entrada para cifrar datos arbitrarios utilizando el algoritmo correcto y la clave asimétrica.

Esto se vuelve peligroso cuando hay otras entradas controlables por el usuario en la aplicación que esperan datos cifrados con el mismo algoritmo. En este caso, un atacante podría utilizar el oracle de cifrado para generar una entrada cifrada válida y luego pasarla a otras funciones sensibles.

Este problema puede agravarse si hay otra entrada controlable por el usuario en el sitio que proporciona la función inversa. Esto permitiría al atacante descifrar otros datos para identificar la estructura esperada. Esto les ahorra parte del trabajo que supone crear sus datos maliciosos, pero no es necesariamente necesario para elaborar un exploit exitoso.

La gravedad de un oráculo de cifrado depende de qué funcionalidad utiliza también el mismo algoritmo que el oráculo.

### Lab: Authentication bypass via encryption oracle
